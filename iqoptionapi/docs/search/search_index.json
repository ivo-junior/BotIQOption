{"config":{"lang":["pt","en","es"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IQOPTION API SUPPORTED BY COMMUNITY \u00b6 This api is intended to be an open source project to communicate with iqOption site. this is a no official repository, it means it is maintained by community Esta API \u00e9 destinada a ser um projeto de c\u00f3digo aberto para se comunicar com o site da iqOption. este \u00e9 um reposit\u00f3rio n\u00e3o oficial, significa que \u00e9 mantido pela comunidade Esta API est\u00e1 destinada a ser un proyecto de c\u00f3digo abierto para comunicarse con el sitio de IqIoption. este es un repositorio no oficial, significa que es mantenido por la comunidad Idiomas | Languages","title":"Home"},{"location":"#iqoption-api-supported-by-community","text":"This api is intended to be an open source project to communicate with iqOption site. this is a no official repository, it means it is maintained by community Esta API \u00e9 destinada a ser um projeto de c\u00f3digo aberto para se comunicar com o site da iqOption. este \u00e9 um reposit\u00f3rio n\u00e3o oficial, significa que \u00e9 mantido pela comunidade Esta API est\u00e1 destinada a ser un proyecto de c\u00f3digo abierto para comunicarse con el sitio de IqIoption. este es un repositorio no oficial, significa que es mantenido por la comunidad","title":"IQOPTION API SUPPORTED BY COMMUNITY"},{"location":"en/","text":"Get start \u00b6 Install iqoptionapi \u00b6 You can download the source code and run this python setup.py install or install using (you need git installed ): pip install -U git+git://github.com/iqoptionapi/iqoptionapi.git little sample \u00b6 import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ())) Import \u00b6 from iqoptionapi.stable_api import IQ_Option Login \u00b6 Iq.connect() will return (check,reason) if connect sucess return True,None if connect fail return False,reason from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) check , reason = Iq . connect () #connect to iqoption print ( check , reason ) Debug mode on \u00b6 import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Connect&Check connect \u00b6 some time connect will close so this way can check connect and reconnect try close your network and restart network in this sample from iqoptionapi.stable_api import IQ_Option error_password = \"\"\"{\"code\":\"invalid_credentials\",\"message\":\"You entered the wrong credentials. Please check that the login/password is correct.\"}\"\"\" iqoption = IQ_Option ( \"email\" , \"password\" ) check , reason = iqoption . connect () if check : print ( \"Start your robot\" ) #if see this you can close network for test while True : if iqoption . check_connect () == False : #detect the websocket is close print ( \"try reconnect\" ) check , reason = iqoption . connect () if check : print ( \"Reconnect successfully\" ) else : if reason == error_password : print ( \"Error Password\" ) else : print ( \"No Network\" ) else : if reason == \"[Errno -2] Name or service not known\" : print ( \"No Network\" ) elif reason == error_password : print ( \"Error Password\" ) set_session \u00b6 Default User-Agent is \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) #Default is \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" header = { \"User-Agent\" : r \"Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0\" } cookie = { \"Iq\" : \"GOOD\" } Iq . set_session ( header , cookie ) Iq . connect () #connect to iqoption Check version \u00b6 from iqoptionapi.stable_api import IQ_Option print ( IQ_Option . __version__ ) Check connect \u00b6 return True/False print(Iq.check_connect()) Reconnect \u00b6 Iq . connect () time \u00b6 get_server_timestamp the get_server_timestamp time is sync with iqoption Iq . get_server_timestamp ()","title":"Get Start"},{"location":"en/#get-start","text":"","title":"Get start"},{"location":"en/#install-iqoptionapi","text":"You can download the source code and run this python setup.py install or install using (you need git installed ): pip install -U git+git://github.com/iqoptionapi/iqoptionapi.git","title":"Install iqoptionapi"},{"location":"en/#little-sample","text":"import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ()))","title":"little sample"},{"location":"en/#import","text":"from iqoptionapi.stable_api import IQ_Option","title":"Import"},{"location":"en/#login","text":"Iq.connect() will return (check,reason) if connect sucess return True,None if connect fail return False,reason from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) check , reason = Iq . connect () #connect to iqoption print ( check , reason )","title":"Login"},{"location":"en/#debug-mode-on","text":"import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' )","title":"Debug mode on"},{"location":"en/#connectcheck-connect","text":"some time connect will close so this way can check connect and reconnect try close your network and restart network in this sample from iqoptionapi.stable_api import IQ_Option error_password = \"\"\"{\"code\":\"invalid_credentials\",\"message\":\"You entered the wrong credentials. Please check that the login/password is correct.\"}\"\"\" iqoption = IQ_Option ( \"email\" , \"password\" ) check , reason = iqoption . connect () if check : print ( \"Start your robot\" ) #if see this you can close network for test while True : if iqoption . check_connect () == False : #detect the websocket is close print ( \"try reconnect\" ) check , reason = iqoption . connect () if check : print ( \"Reconnect successfully\" ) else : if reason == error_password : print ( \"Error Password\" ) else : print ( \"No Network\" ) else : if reason == \"[Errno -2] Name or service not known\" : print ( \"No Network\" ) elif reason == error_password : print ( \"Error Password\" )","title":"Connect&amp;Check connect"},{"location":"en/#set_session","text":"Default User-Agent is \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) #Default is \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" header = { \"User-Agent\" : r \"Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0\" } cookie = { \"Iq\" : \"GOOD\" } Iq . set_session ( header , cookie ) Iq . connect () #connect to iqoption","title":"set_session"},{"location":"en/#check-version","text":"from iqoptionapi.stable_api import IQ_Option print ( IQ_Option . __version__ )","title":"Check version"},{"location":"en/#check-connect","text":"return True/False print(Iq.check_connect())","title":"Check connect"},{"location":"en/#reconnect","text":"Iq . connect ()","title":"Reconnect"},{"location":"en/#time","text":"get_server_timestamp the get_server_timestamp time is sync with iqoption Iq . get_server_timestamp ()","title":"time"},{"location":"en/account/account/","text":"Account \u00b6 get_balance() \u00b6 Iq . get_balance () get_balance_v2() \u00b6 more accuracy Iq . get_balance_v2 () get_currency() \u00b6 you will check what currency you use Iq . get_currency () reset_practice_balance() \u00b6 reset practice balance to $10000 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption print ( Iq . reset_practice_balance ()) Change real/practice Account \u00b6 MODE=\"PRACTICE\"/\"REAL\"/\"TOURNAMENT\" PRACTICE - it is demo account REAL - It is our money in risk TOURNAMENT - Tournaments account balance_type = \"PRACTICE\" Iq . change_balance ( balance_type ) get Other People stratagy \u00b6 sample \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #For digital option name = \"live-deal-digital-option\" #\"live-deal-binary-option-placed\"/\"live-deal-digital-option\" active = \"EURUSD\" _type = \"PT1M\" #\"PT1M\"/\"PT5M\"/\"PT15M\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : #data size is below buffersize #data[0] is the last data data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_digital_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) #For binary option name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : #data size is below buffersize #data[0] is the last data data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_binary_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) subscribe_live_deal \u00b6 Iq . subscribe_live_deal ( name , active , _type , buffersize ) unscribe_live_deal \u00b6 Iq . unscribe_live_deal ( name , active , _type ) get_live_deal \u00b6 Iq . get_live_deal ( name , active , _type ) pop_live_deal \u00b6 pop the data from list Iq . pop_live_deal ( name , active , _type ) get Other people detail \u00b6 sample \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #For binary option name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) print ( \" \\n\\n \" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) last_trade_data = Iq . get_live_deal ( name , active , _type )[ 0 ] user_id = last_trade_data [ \"user_id\" ] counutry_id = last_trade_data [ \"country_id\" ] print ( \"_______get_user_profile_client__________\" ) print ( Iq . get_user_profile_client ( user_id )) pro_data = Iq . get_user_profile_client ( user_id ) print ( \" \\n\\n \" ) print ( \"___________request_leaderboard_userinfo_deals_client______\" ) print ( Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id )) user_data = Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id ) worldwide = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"position\" ] profit = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"score\" ] print ( \" \\n \" ) print ( \"user_name:\" + pro_data [ \"user_name\" ]) print ( \"This week worldwide:\" + str ( worldwide )) print ( \"This week's gross profit:\" + str ( profit )) print ( \" \\n\\n \" ) print ( \"___________get_users_availability____________\" ) print ( Iq . get_users_availability ( user_id )) print ( \" \\n\\n \" ) print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) get_user_profile_client() \u00b6 this api can get user name and image Iq . get_user_profile_client ( user_id ) request_leaderboard_userinfo_deals_client() \u00b6 this api can get user detail Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id ) get_users_availability() \u00b6 Iq . get_users_availability ( user_id )","title":"Account"},{"location":"en/account/account/#account","text":"","title":"Account"},{"location":"en/account/account/#get_balance","text":"Iq . get_balance ()","title":"get_balance()"},{"location":"en/account/account/#get_balance_v2","text":"more accuracy Iq . get_balance_v2 ()","title":"get_balance_v2()"},{"location":"en/account/account/#get_currency","text":"you will check what currency you use Iq . get_currency ()","title":"get_currency()"},{"location":"en/account/account/#reset_practice_balance","text":"reset practice balance to $10000 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption print ( Iq . reset_practice_balance ())","title":"reset_practice_balance()"},{"location":"en/account/account/#change-realpractice-account","text":"MODE=\"PRACTICE\"/\"REAL\"/\"TOURNAMENT\" PRACTICE - it is demo account REAL - It is our money in risk TOURNAMENT - Tournaments account balance_type = \"PRACTICE\" Iq . change_balance ( balance_type )","title":"Change real/practice Account"},{"location":"en/account/account/#get-other-people-stratagy","text":"","title":"get Other People stratagy"},{"location":"en/account/account/#sample","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #For digital option name = \"live-deal-digital-option\" #\"live-deal-binary-option-placed\"/\"live-deal-digital-option\" active = \"EURUSD\" _type = \"PT1M\" #\"PT1M\"/\"PT5M\"/\"PT15M\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : #data size is below buffersize #data[0] is the last data data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_digital_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) #For binary option name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : #data size is below buffersize #data[0] is the last data data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_binary_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type )","title":"sample"},{"location":"en/account/account/#subscribe_live_deal","text":"Iq . subscribe_live_deal ( name , active , _type , buffersize )","title":"subscribe_live_deal"},{"location":"en/account/account/#unscribe_live_deal","text":"Iq . unscribe_live_deal ( name , active , _type )","title":"unscribe_live_deal"},{"location":"en/account/account/#get_live_deal","text":"Iq . get_live_deal ( name , active , _type )","title":"get_live_deal"},{"location":"en/account/account/#pop_live_deal","text":"pop the data from list Iq . pop_live_deal ( name , active , _type )","title":"pop_live_deal"},{"location":"en/account/account/#get-other-people-detail","text":"","title":"get Other people detail"},{"location":"en/account/account/#sample_1","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #For binary option name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) print ( \" \\n\\n \" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) last_trade_data = Iq . get_live_deal ( name , active , _type )[ 0 ] user_id = last_trade_data [ \"user_id\" ] counutry_id = last_trade_data [ \"country_id\" ] print ( \"_______get_user_profile_client__________\" ) print ( Iq . get_user_profile_client ( user_id )) pro_data = Iq . get_user_profile_client ( user_id ) print ( \" \\n\\n \" ) print ( \"___________request_leaderboard_userinfo_deals_client______\" ) print ( Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id )) user_data = Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id ) worldwide = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"position\" ] profit = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"score\" ] print ( \" \\n \" ) print ( \"user_name:\" + pro_data [ \"user_name\" ]) print ( \"This week worldwide:\" + str ( worldwide )) print ( \"This week's gross profit:\" + str ( profit )) print ( \" \\n\\n \" ) print ( \"___________get_users_availability____________\" ) print ( Iq . get_users_availability ( user_id )) print ( \" \\n\\n \" ) print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type )","title":"sample"},{"location":"en/account/account/#get_user_profile_client","text":"this api can get user name and image Iq . get_user_profile_client ( user_id )","title":"get_user_profile_client()"},{"location":"en/account/account/#request_leaderboard_userinfo_deals_client","text":"this api can get user detail Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id )","title":"request_leaderboard_userinfo_deals_client()"},{"location":"en/account/account/#get_users_availability","text":"Iq . get_users_availability ( user_id )","title":"get_users_availability()"},{"location":"en/all/all/","text":"For all \u00b6 this api can work for option&digital&Forex&Stock&Commodities&Crypto&ETFs Check Asset if open or not \u00b6 be careful get_all_open_time() is very heavy for network. get_all_open_time() return the DICT \"cfd\" is include Stock,Commodities,ETFs asset DICT[\"forex\"/\"cfd\"/\"crypto\"/\"digital\"/\"turbo\"/\"binary\"][Asset Name][\"open\"] it will return True/False from iqoptionapi.stable_api import IQ_Option import logging import random logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ALL_Asset = Iq . get_all_open_time () #check if open or not print ( ALL_Asset [ \"forex\" ][ \"EURUSD\" ][ \"open\" ]) print ( ALL_Asset [ \"cfd\" ][ \"FACEBOOK\" ][ \"open\" ]) #Stock,Commodities,ETFs print ( ALL_Asset [ \"crypto\" ][ \"BTCUSD-L\" ][ \"open\" ]) print ( ALL_Asset [ \"digital\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #Binary have two diffenence type:\"turbo\",\"binary\" print ( ALL_Asset [ \"turbo\" ][ \"EURUSD-OTC\" ][ \"open\" ]) print ( ALL_Asset [ \"binary\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #!!!! exception \"\" print ( ALL_Asset [ \"binary\" ][ \"not exist asset\" ][ \"open\" ]) #it will return \"{}\" a None of the dict #!!!!print all!!!! for type_name , data in ALL_Asset . items (): for Asset , value in data . items (): print ( type_name , Asset , value [ \"open\" ]) View all ACTIVES Name \u00b6 print(Iq.get_all_ACTIVES_OPCODE()) update ACTIVES OPCODE \u00b6 Iq.update_ACTIVES_OPCODE() get_async_order() \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put print ( \"__For_Binary_Option__\" ) _ , id = Iq . buy ( amount , ACTIVES , action , duration ) while Iq . get_async_order ( id ) == None : pass print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__For_Digital_Option__spot\" ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__For_Forex_Stock_Commodities_Crypto_ETFs\" ) instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" amount = 1.23 leverage = 3 type = \"market\" limit_price = None stop_price = None stop_lose_kind = \"percent\" stop_lose_value = 95 take_profit_kind = None take_profit_value = None use_trail_stop = True auto_margin_call = False use_token_for_commission = False check , id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id )) get_commission_change() \u00b6 instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" Iq.subscribe_commission_changed(instrument_type) Iq.get_commission_change(instrument_type) Iq.unsubscribe_commission_changed(instrument_type) Sample code import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption #instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" instrument_type = [ \"binary-option\" , \"turbo-option\" , \"digital-option\" , \"crypto\" , \"forex\" , \"cfd\" ] for ins in instrument_type : Iq . subscribe_commission_changed ( ins ) print ( \"Start stream please wait profit change...\" ) while True : for ins in instrument_type : commissio_data = Iq . get_commission_change ( ins ) if commissio_data != {}: for active_name in commissio_data : if commissio_data [ active_name ] != {}: the_min_timestamp = min ( commissio_data [ active_name ] . keys ()) commissio = commissio_data [ active_name ][ the_min_timestamp ] profit = ( 100 - commissio ) / 100 print ( \"instrument_type: \" + str ( ins ) + \" active_name: \" + str ( active_name ) + \" profit change to: \" + str ( profit )) #Data have been update so need del del Iq . get_commission_change ( ins )[ active_name ][ the_min_timestamp ] time . sleep ( 1 ) Get top_assets_updated \u00b6 smaple \u00b6 instrument_type=\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : print ( Iq . get_top_assets_updated ( instrument_type )) print ( \" \\n\\n \" ) time . sleep ( 1 ) Iq . unsubscribe_top_assets_updated ( instrument_type ) subscribe_top_assets_updated() \u00b6 instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) get_top_assets_updated() \u00b6 need call get_top_assets_updated() after subscribe_top_assets_updated() Iq . get_top_assets_updated ( instrument_type ) unsubscribe_top_assets_updated() \u00b6 if you not using please close stram for safe network Iq . unsubscribe_top_assets_updated ( instrument_type ) get sort by popularity \u00b6 sample \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time import operator #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') def opcode_to_name ( opcode_data , opcode ): return list ( opcode_data . keys ())[ list ( opcode_data . values ()) . index ( opcode )] Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Iq . update_ACTIVES_OPCODE () opcode_data = Iq . get_all_ACTIVES_OPCODE () instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : break top_assets = Iq . get_top_assets_updated ( instrument_type ) popularity = {} for asset in top_assets : opcode = asset [ \"active_id\" ] popularity_value = asset [ \"popularity\" ][ \"value\" ] try : name = opcode_to_name ( opcode_data , opcode ) popularity [ name ] = popularity_value except : pass sorted_popularity = sorted ( popularity . items (), key = operator . itemgetter ( 1 )) print ( \"__Popularity_min_to_max__\" ) for lis in sorted_popularity : print ( lis ) Iq . unsubscribe_top_assets_updated ( instrument_type ) get_leader_board \u00b6 Get leader board data from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( email , password ) Iq . connect () #connect to iqoption country = \"TW\" from_position = 1 to_position = 1 near_traders_count = 0 print ( Iq . get_leader_board ( country , from_position , to_position , near_traders_count )) Country ID = {\"Worldwide\":0, \"AF\": 1, \"AL\": 2, \"DZ\": 3, \"AD\": 5, \"AO\": 6, \"AI\": 7, \"AG\": 9, \"AR\": 10, \"AM\": 11, \"AW\": 12, \"AT\": 14, \"AZ\": 15, \"BS\": 16, \"BH\": 17, \"BD\": 18, \"BB\": 19, \"BY\": 20, \"BZ\": 22, \"BJ\": 23, \"BM\": 24, \"BO\": 26, \"BA\": 27, \"BW\": 28, \"BV\": 29, \"BR\": 30, \"BN\": 31, \"BG\": 32, \"BF\": 33, \"BI\": 34, \"KH\": 35, \"CM\": 36, \"CV\": 38, \"KY\": 39, \"TD\": 41, \"CL\": 42, \"CN\": 43, \"CC\": 45, \"CO\": 46, \"KM\": 47, \"CG\": 48, \"CK\": 49, \"CR\": 50, \"CI\": 51, \"HR\": 52, \"CU\": 53, \"CY\": 54, \"CZ\": 55, \"DK\": 56, \"DJ\": 57, \"DM\": 58, \"DO\": 59, \"TL\": 60, \"EC\": 61, \"EG\": 62, \"SV\": 63, \"EE\": 66, \"ET\": 67, \"FO\": 69, \"FJ\": 70, \"FI\": 71, \"FR\": 72, \"GF\": 73, \"PF\": 74, \"GA\": 75, \"GM\": 76, \"GE\": 77, \"DE\": 78, \"GH\": 79, \"GR\": 81, \"GD\": 83, \"GP\": 84, \"GT\": 86, \"GN\": 87, \"GY\": 88, \"HT\": 89, \"HN\": 90, \"HK\": 91, \"HU\": 92, \"IS\": 93, \"ID\": 94, \"IQ\": 95, \"IE\": 96, \"IT\": 97, \"JM\": 98, \"JO\": 100, \"KZ\": 101, \"KE\": 102, \"KI\": 103, \"KW\": 104, \"KG\": 105, \"LA\": 106, \"LV\": 107, \"LB\": 108, \"LS\": 109, \"LR\": 110, \"LY\": 111, \"LT\": 113, \"LU\": 114, \"MO\": 115, \"MK\": 116, \"MG\": 117, \"MW\": 118, \"MY\": 119, \"MV\": 120, \"ML\": 121, \"MT\": 122, \"MQ\": 124, \"MR\": 125, \"MU\": 126, \"MX\": 128, \"FM\": 129, \"MD\": 130, \"MC\": 131, \"MN\": 132, \"MA\": 134, \"MZ\": 135, \"MM\": 136, \"NA\": 137, \"NP\": 139, \"NL\": 140, \"AN\": 141, \"NC\": 142, \"NZ\": 143, \"NI\": 144, \"NE\": 145, \"NG\": 146, \"NO\": 149, \"OM\": 150, \"PK\": 151, \"PW\": 152, \"PA\": 153, \"PG\": 154, \"PY\": 155, \"PE\": 156, \"PH\": 157, \"PL\": 159, \"PT\": 160, \"QA\": 162, \"RE\": 163, \"RO\": 164, \"RW\": 166, \"KN\": 167, \"LC\": 168, \"SA\": 171, \"SN\": 172, \"SC\": 173, \"SG\": 175, \"SK\": 176, \"SI\": 177, \"SO\": 179, \"ZA\": 180, \"KR\": 181, \"ES\": 182, \"LK\": 183, \"SH\": 184, \"SR\": 186, \"SZ\": 187, \"SE\": 188, \"CH\": 189, \"TW\": 191, \"TJ\": 192, \"TZ\": 193, \"TH\": 194, \"TG\": 195, \"TT\": 198, \"TN\": 199, \"TR\": 200, \"TM\": 201, \"UG\": 203, \"UA\": 204, \"AE\": 205, \"GB\": 206, \"UY\": 207, \"UZ\": 208, \"VE\": 211, \"VN\": 212, \"VG\": 213, \"YE\": 216, \"ZM\": 218, \"ZW\": 219, \"RS\": 220, \"ME\": 221, \"IN\": 225, \"TC\": 234, \"CD\": 235, \"GG\": 236, \"IM\": 237, \"JE\": 239, \"CW\": 246, }","title":"For all"},{"location":"en/all/all/#for-all","text":"this api can work for option&digital&Forex&Stock&Commodities&Crypto&ETFs","title":"For all"},{"location":"en/all/all/#check-asset-if-open-or-not","text":"be careful get_all_open_time() is very heavy for network. get_all_open_time() return the DICT \"cfd\" is include Stock,Commodities,ETFs asset DICT[\"forex\"/\"cfd\"/\"crypto\"/\"digital\"/\"turbo\"/\"binary\"][Asset Name][\"open\"] it will return True/False from iqoptionapi.stable_api import IQ_Option import logging import random logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ALL_Asset = Iq . get_all_open_time () #check if open or not print ( ALL_Asset [ \"forex\" ][ \"EURUSD\" ][ \"open\" ]) print ( ALL_Asset [ \"cfd\" ][ \"FACEBOOK\" ][ \"open\" ]) #Stock,Commodities,ETFs print ( ALL_Asset [ \"crypto\" ][ \"BTCUSD-L\" ][ \"open\" ]) print ( ALL_Asset [ \"digital\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #Binary have two diffenence type:\"turbo\",\"binary\" print ( ALL_Asset [ \"turbo\" ][ \"EURUSD-OTC\" ][ \"open\" ]) print ( ALL_Asset [ \"binary\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #!!!! exception \"\" print ( ALL_Asset [ \"binary\" ][ \"not exist asset\" ][ \"open\" ]) #it will return \"{}\" a None of the dict #!!!!print all!!!! for type_name , data in ALL_Asset . items (): for Asset , value in data . items (): print ( type_name , Asset , value [ \"open\" ])","title":"Check Asset if open or not"},{"location":"en/all/all/#view-all-actives-name","text":"print(Iq.get_all_ACTIVES_OPCODE())","title":"View all ACTIVES Name"},{"location":"en/all/all/#update-actives-opcode","text":"Iq.update_ACTIVES_OPCODE()","title":"update ACTIVES OPCODE"},{"location":"en/all/all/#get_async_order","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put print ( \"__For_Binary_Option__\" ) _ , id = Iq . buy ( amount , ACTIVES , action , duration ) while Iq . get_async_order ( id ) == None : pass print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__For_Digital_Option__spot\" ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__For_Forex_Stock_Commodities_Crypto_ETFs\" ) instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" amount = 1.23 leverage = 3 type = \"market\" limit_price = None stop_price = None stop_lose_kind = \"percent\" stop_lose_value = 95 take_profit_kind = None take_profit_value = None use_trail_stop = True auto_margin_call = False use_token_for_commission = False check , id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id ))","title":"get_async_order()"},{"location":"en/all/all/#get_commission_change","text":"instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" Iq.subscribe_commission_changed(instrument_type) Iq.get_commission_change(instrument_type) Iq.unsubscribe_commission_changed(instrument_type) Sample code import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption #instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" instrument_type = [ \"binary-option\" , \"turbo-option\" , \"digital-option\" , \"crypto\" , \"forex\" , \"cfd\" ] for ins in instrument_type : Iq . subscribe_commission_changed ( ins ) print ( \"Start stream please wait profit change...\" ) while True : for ins in instrument_type : commissio_data = Iq . get_commission_change ( ins ) if commissio_data != {}: for active_name in commissio_data : if commissio_data [ active_name ] != {}: the_min_timestamp = min ( commissio_data [ active_name ] . keys ()) commissio = commissio_data [ active_name ][ the_min_timestamp ] profit = ( 100 - commissio ) / 100 print ( \"instrument_type: \" + str ( ins ) + \" active_name: \" + str ( active_name ) + \" profit change to: \" + str ( profit )) #Data have been update so need del del Iq . get_commission_change ( ins )[ active_name ][ the_min_timestamp ] time . sleep ( 1 )","title":"get_commission_change()"},{"location":"en/all/all/#get-top_assets_updated","text":"","title":"Get top_assets_updated"},{"location":"en/all/all/#smaple","text":"instrument_type=\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : print ( Iq . get_top_assets_updated ( instrument_type )) print ( \" \\n\\n \" ) time . sleep ( 1 ) Iq . unsubscribe_top_assets_updated ( instrument_type )","title":"smaple"},{"location":"en/all/all/#subscribe_top_assets_updated","text":"instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type )","title":"subscribe_top_assets_updated()"},{"location":"en/all/all/#get_top_assets_updated","text":"need call get_top_assets_updated() after subscribe_top_assets_updated() Iq . get_top_assets_updated ( instrument_type )","title":"get_top_assets_updated()"},{"location":"en/all/all/#unsubscribe_top_assets_updated","text":"if you not using please close stram for safe network Iq . unsubscribe_top_assets_updated ( instrument_type )","title":"unsubscribe_top_assets_updated()"},{"location":"en/all/all/#get-sort-by-popularity","text":"","title":"get sort by popularity"},{"location":"en/all/all/#sample","text":"from iqoptionapi.stable_api import IQ_Option import logging import time import operator #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') def opcode_to_name ( opcode_data , opcode ): return list ( opcode_data . keys ())[ list ( opcode_data . values ()) . index ( opcode )] Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Iq . update_ACTIVES_OPCODE () opcode_data = Iq . get_all_ACTIVES_OPCODE () instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : break top_assets = Iq . get_top_assets_updated ( instrument_type ) popularity = {} for asset in top_assets : opcode = asset [ \"active_id\" ] popularity_value = asset [ \"popularity\" ][ \"value\" ] try : name = opcode_to_name ( opcode_data , opcode ) popularity [ name ] = popularity_value except : pass sorted_popularity = sorted ( popularity . items (), key = operator . itemgetter ( 1 )) print ( \"__Popularity_min_to_max__\" ) for lis in sorted_popularity : print ( lis ) Iq . unsubscribe_top_assets_updated ( instrument_type )","title":"sample"},{"location":"en/all/all/#get_leader_board","text":"Get leader board data from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( email , password ) Iq . connect () #connect to iqoption country = \"TW\" from_position = 1 to_position = 1 near_traders_count = 0 print ( Iq . get_leader_board ( country , from_position , to_position , near_traders_count )) Country ID = {\"Worldwide\":0, \"AF\": 1, \"AL\": 2, \"DZ\": 3, \"AD\": 5, \"AO\": 6, \"AI\": 7, \"AG\": 9, \"AR\": 10, \"AM\": 11, \"AW\": 12, \"AT\": 14, \"AZ\": 15, \"BS\": 16, \"BH\": 17, \"BD\": 18, \"BB\": 19, \"BY\": 20, \"BZ\": 22, \"BJ\": 23, \"BM\": 24, \"BO\": 26, \"BA\": 27, \"BW\": 28, \"BV\": 29, \"BR\": 30, \"BN\": 31, \"BG\": 32, \"BF\": 33, \"BI\": 34, \"KH\": 35, \"CM\": 36, \"CV\": 38, \"KY\": 39, \"TD\": 41, \"CL\": 42, \"CN\": 43, \"CC\": 45, \"CO\": 46, \"KM\": 47, \"CG\": 48, \"CK\": 49, \"CR\": 50, \"CI\": 51, \"HR\": 52, \"CU\": 53, \"CY\": 54, \"CZ\": 55, \"DK\": 56, \"DJ\": 57, \"DM\": 58, \"DO\": 59, \"TL\": 60, \"EC\": 61, \"EG\": 62, \"SV\": 63, \"EE\": 66, \"ET\": 67, \"FO\": 69, \"FJ\": 70, \"FI\": 71, \"FR\": 72, \"GF\": 73, \"PF\": 74, \"GA\": 75, \"GM\": 76, \"GE\": 77, \"DE\": 78, \"GH\": 79, \"GR\": 81, \"GD\": 83, \"GP\": 84, \"GT\": 86, \"GN\": 87, \"GY\": 88, \"HT\": 89, \"HN\": 90, \"HK\": 91, \"HU\": 92, \"IS\": 93, \"ID\": 94, \"IQ\": 95, \"IE\": 96, \"IT\": 97, \"JM\": 98, \"JO\": 100, \"KZ\": 101, \"KE\": 102, \"KI\": 103, \"KW\": 104, \"KG\": 105, \"LA\": 106, \"LV\": 107, \"LB\": 108, \"LS\": 109, \"LR\": 110, \"LY\": 111, \"LT\": 113, \"LU\": 114, \"MO\": 115, \"MK\": 116, \"MG\": 117, \"MW\": 118, \"MY\": 119, \"MV\": 120, \"ML\": 121, \"MT\": 122, \"MQ\": 124, \"MR\": 125, \"MU\": 126, \"MX\": 128, \"FM\": 129, \"MD\": 130, \"MC\": 131, \"MN\": 132, \"MA\": 134, \"MZ\": 135, \"MM\": 136, \"NA\": 137, \"NP\": 139, \"NL\": 140, \"AN\": 141, \"NC\": 142, \"NZ\": 143, \"NI\": 144, \"NE\": 145, \"NG\": 146, \"NO\": 149, \"OM\": 150, \"PK\": 151, \"PW\": 152, \"PA\": 153, \"PG\": 154, \"PY\": 155, \"PE\": 156, \"PH\": 157, \"PL\": 159, \"PT\": 160, \"QA\": 162, \"RE\": 163, \"RO\": 164, \"RW\": 166, \"KN\": 167, \"LC\": 168, \"SA\": 171, \"SN\": 172, \"SC\": 173, \"SG\": 175, \"SK\": 176, \"SI\": 177, \"SO\": 179, \"ZA\": 180, \"KR\": 181, \"ES\": 182, \"LK\": 183, \"SH\": 184, \"SR\": 186, \"SZ\": 187, \"SE\": 188, \"CH\": 189, \"TW\": 191, \"TJ\": 192, \"TZ\": 193, \"TH\": 194, \"TG\": 195, \"TT\": 198, \"TN\": 199, \"TR\": 200, \"TM\": 201, \"UG\": 203, \"UA\": 204, \"AE\": 205, \"GB\": 206, \"UY\": 207, \"UZ\": 208, \"VE\": 211, \"VN\": 212, \"VG\": 213, \"YE\": 216, \"ZM\": 218, \"ZW\": 219, \"RS\": 220, \"ME\": 221, \"IN\": 225, \"TC\": 234, \"CD\": 235, \"GG\": 236, \"IM\": 237, \"JE\": 239, \"CW\": 246, }","title":"get_leader_board"},{"location":"en/binary%20option/binary%20option/","text":"For Binary Option \u00b6 buy \u00b6 buy the binary option buy() \u00b6 sample from iqoptionapi.stable_api import IQ_Option import logging import time logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"pass\" ) goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ())) Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 check , id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) if check : print ( \"!buy!\" ) else : print ( \"buy fail\" ) Iq . buy ( Money , ACTIVES , ACTION , expirations ) #Money:How many you want to buy type(int) #ACTIVES:sample input \"EURUSD\" OR \"EURGBP\".... you can view by get_all_ACTIVES_OPCODE #ACTION:\"call\"/\"put\" type(str) #expirations:input minute,careful too large will false to buy(Closed market time)thank Darth-Carrotpie's code (int)https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/6 #return:if sucess return (True,id_number) esle return(Fale,None) buy_multi() \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Money = [] ACTIVES = [] ACTION = [] expirations_mode = [] Money . append ( 1 ) ACTIVES . append ( \"EURUSD\" ) ACTION . append ( \"call\" ) #put expirations_mode . append ( 1 ) Money . append ( 1 ) ACTIVES . append ( \"EURAUD\" ) ACTION . append ( \"call\" ) #put expirations_mode . append ( 1 ) print ( \"buy multi\" ) id_list = Iq . buy_multi ( Money , ACTIVES , ACTION , expirations_mode ) print ( \"check win only one id (id_list[0])\" ) print ( Iq . check_win_v2 ( id_list [ 0 ], 2 )) buy_by_raw_expirations() \u00b6 buy the binary optoin by expired price = 2 active = \"EURUSD\" direction = \"call\" #put option = \"turbo\" #binary expired = 1293923 # this expried time you need to count or get by your self Iq . buy_by_raw_expirations ( price , active , direction , option , expired ) get_remaning() \u00b6 purchase time=remaning time - 30 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 while True : remaning_time = Iq . get_remaning ( expirations_mode ) purchase_time = remaning_time - 30 if purchase_time < 4 : #buy the binary option at purchase_time<4 Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) break sell_option() \u00b6 Iq . sell_option ( sell_all ) #input int or list order id Sample from iqoptionapi.stable_api import IQ_Option import time print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) id2 = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) time . sleep ( 5 ) sell_all = [] sell_all . append ( id ) sell_all . append ( id2 ) print ( Iq . sell_option ( sell_all )) check win \u00b6 It will do loop until get win or loose check_win() \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"start check win please wait\" ) print ( Iq . check_win ( id )) Iq . check_win ( 23243221 ) #\"\"you need to get id_number from buy function\"\" #Iq.check_win(id_number) #this function will do loop check your bet until if win/equal/loose check_win_v2() \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"start check win please wait\" ) polling_time = 3 print ( Iq . check_win_v2 ( id , polling_time )) check_win_v3() \u00b6 great way from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"start check win please wait\" ) print ( Iq . check_win_v3 ( id )) get_binary_option_detail() \u00b6 sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_binary_option_detail () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ]) get_all_init() \u00b6 get_binary_option_detail is base on this api you will get the raw detail about binary option Iq.get_all_init() get_all_profit() \u00b6 sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_all_profit () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ]) if you want realtime profit try this get real time profit get_betinfo() \u00b6 if order not close yet or wrong id it will return False isSuccessful , dict = Iq . get_betinfo ( 4452272449 ) #Iq.get_betinfo #INPUT: order id #OUTPUT:isSuccessful,dict get_optioninfo \u00b6 get_optioninfo() \u00b6 input how many data you want to get from Trading History(only for binary option) print ( Iq . get_optioninfo ( 10 )) get_optioninfo_v2() \u00b6 input how many data you want to get from Trading History(only for binary option) print ( Iq . get_optioninfo_v2 ( 10 )) get_option_open_by_other_pc() \u00b6 if your account is login in other plance/PC and doing buy option you can get the option by this function import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while True : #please open website iqoption and buy some binary option if Iq . get_option_open_by_other_pc () != {}: break time . sleep ( 1 ) print ( \"Get option from other Pc and same account\" ) print ( Iq . get_option_open_by_other_pc ()) id = list ( Iq . get_option_open_by_other_pc () . keys ())[ 0 ] Iq . del_option_open_by_other_pc ( id ) print ( \"After del by id\" ) print ( Iq . get_option_open_by_other_pc ()) Get mood \u00b6 sample \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" Iq . start_mood_stream ( goal ) print ( Iq . get_traders_mood ( goal )) Iq . stop_mood_stream ( goal ) start_mood_stream() \u00b6 Iq . start_mood_stream ( goal ) get_traders_mood() \u00b6 call get_traders_mood() after start_mood_stream Iq . get_traders_mood ( goal ) get_all_traders_mood() \u00b6 it will get all trade mood what you start stream Iq . get_all_traders_mood () #output:(dict) all mood you start stop_mood_stream() \u00b6 if you not using the mood ,please stop safe network Iq . stop_mood_stream ( goal )","title":"Binary option"},{"location":"en/binary%20option/binary%20option/#for-binary-option","text":"","title":"For Binary Option"},{"location":"en/binary%20option/binary%20option/#buy","text":"buy the binary option","title":"buy"},{"location":"en/binary%20option/binary%20option/#buy_1","text":"sample from iqoptionapi.stable_api import IQ_Option import logging import time logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"pass\" ) goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ())) Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 check , id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) if check : print ( \"!buy!\" ) else : print ( \"buy fail\" ) Iq . buy ( Money , ACTIVES , ACTION , expirations ) #Money:How many you want to buy type(int) #ACTIVES:sample input \"EURUSD\" OR \"EURGBP\".... you can view by get_all_ACTIVES_OPCODE #ACTION:\"call\"/\"put\" type(str) #expirations:input minute,careful too large will false to buy(Closed market time)thank Darth-Carrotpie's code (int)https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/6 #return:if sucess return (True,id_number) esle return(Fale,None)","title":"buy()"},{"location":"en/binary%20option/binary%20option/#buy_multi","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Money = [] ACTIVES = [] ACTION = [] expirations_mode = [] Money . append ( 1 ) ACTIVES . append ( \"EURUSD\" ) ACTION . append ( \"call\" ) #put expirations_mode . append ( 1 ) Money . append ( 1 ) ACTIVES . append ( \"EURAUD\" ) ACTION . append ( \"call\" ) #put expirations_mode . append ( 1 ) print ( \"buy multi\" ) id_list = Iq . buy_multi ( Money , ACTIVES , ACTION , expirations_mode ) print ( \"check win only one id (id_list[0])\" ) print ( Iq . check_win_v2 ( id_list [ 0 ], 2 ))","title":"buy_multi()"},{"location":"en/binary%20option/binary%20option/#buy_by_raw_expirations","text":"buy the binary optoin by expired price = 2 active = \"EURUSD\" direction = \"call\" #put option = \"turbo\" #binary expired = 1293923 # this expried time you need to count or get by your self Iq . buy_by_raw_expirations ( price , active , direction , option , expired )","title":"buy_by_raw_expirations()"},{"location":"en/binary%20option/binary%20option/#get_remaning","text":"purchase time=remaning time - 30 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 while True : remaning_time = Iq . get_remaning ( expirations_mode ) purchase_time = remaning_time - 30 if purchase_time < 4 : #buy the binary option at purchase_time<4 Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) break","title":"get_remaning()"},{"location":"en/binary%20option/binary%20option/#sell_option","text":"Iq . sell_option ( sell_all ) #input int or list order id Sample from iqoptionapi.stable_api import IQ_Option import time print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) id2 = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) time . sleep ( 5 ) sell_all = [] sell_all . append ( id ) sell_all . append ( id2 ) print ( Iq . sell_option ( sell_all ))","title":"sell_option()"},{"location":"en/binary%20option/binary%20option/#check-win","text":"It will do loop until get win or loose","title":"check win"},{"location":"en/binary%20option/binary%20option/#check_win","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"start check win please wait\" ) print ( Iq . check_win ( id )) Iq . check_win ( 23243221 ) #\"\"you need to get id_number from buy function\"\" #Iq.check_win(id_number) #this function will do loop check your bet until if win/equal/loose","title":"check_win()"},{"location":"en/binary%20option/binary%20option/#check_win_v2","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"start check win please wait\" ) polling_time = 3 print ( Iq . check_win_v2 ( id , polling_time ))","title":"check_win_v2()"},{"location":"en/binary%20option/binary%20option/#check_win_v3","text":"great way from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"start check win please wait\" ) print ( Iq . check_win_v3 ( id ))","title":"check_win_v3()"},{"location":"en/binary%20option/binary%20option/#get_binary_option_detail","text":"sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_binary_option_detail () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ])","title":"get_binary_option_detail()"},{"location":"en/binary%20option/binary%20option/#get_all_init","text":"get_binary_option_detail is base on this api you will get the raw detail about binary option Iq.get_all_init()","title":"get_all_init()"},{"location":"en/binary%20option/binary%20option/#get_all_profit","text":"sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_all_profit () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ]) if you want realtime profit try this get real time profit","title":"get_all_profit()"},{"location":"en/binary%20option/binary%20option/#get_betinfo","text":"if order not close yet or wrong id it will return False isSuccessful , dict = Iq . get_betinfo ( 4452272449 ) #Iq.get_betinfo #INPUT: order id #OUTPUT:isSuccessful,dict","title":"get_betinfo()"},{"location":"en/binary%20option/binary%20option/#get_optioninfo","text":"","title":"get_optioninfo"},{"location":"en/binary%20option/binary%20option/#get_optioninfo_1","text":"input how many data you want to get from Trading History(only for binary option) print ( Iq . get_optioninfo ( 10 ))","title":"get_optioninfo()"},{"location":"en/binary%20option/binary%20option/#get_optioninfo_v2","text":"input how many data you want to get from Trading History(only for binary option) print ( Iq . get_optioninfo_v2 ( 10 ))","title":"get_optioninfo_v2()"},{"location":"en/binary%20option/binary%20option/#get_option_open_by_other_pc","text":"if your account is login in other plance/PC and doing buy option you can get the option by this function import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while True : #please open website iqoption and buy some binary option if Iq . get_option_open_by_other_pc () != {}: break time . sleep ( 1 ) print ( \"Get option from other Pc and same account\" ) print ( Iq . get_option_open_by_other_pc ()) id = list ( Iq . get_option_open_by_other_pc () . keys ())[ 0 ] Iq . del_option_open_by_other_pc ( id ) print ( \"After del by id\" ) print ( Iq . get_option_open_by_other_pc ())","title":"get_option_open_by_other_pc()"},{"location":"en/binary%20option/binary%20option/#get-mood","text":"","title":"Get mood"},{"location":"en/binary%20option/binary%20option/#sample","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" Iq . start_mood_stream ( goal ) print ( Iq . get_traders_mood ( goal )) Iq . stop_mood_stream ( goal )","title":"sample"},{"location":"en/binary%20option/binary%20option/#start_mood_stream","text":"Iq . start_mood_stream ( goal )","title":"start_mood_stream()"},{"location":"en/binary%20option/binary%20option/#get_traders_mood","text":"call get_traders_mood() after start_mood_stream Iq . get_traders_mood ( goal )","title":"get_traders_mood()"},{"location":"en/binary%20option/binary%20option/#get_all_traders_mood","text":"it will get all trade mood what you start stream Iq . get_all_traders_mood () #output:(dict) all mood you start","title":"get_all_traders_mood()"},{"location":"en/binary%20option/binary%20option/#stop_mood_stream","text":"if you not using the mood ,please stop safe network Iq . stop_mood_stream ( goal )","title":"stop_mood_stream()"},{"location":"en/candle/candle/","text":"Candle \u00b6 get candles \u00b6 only get close clndle, not realtime Iq.get_candles(ACTIVES,interval,count,endtime) #ACTIVES:sample input \"EURUSD\" OR \"EURGBP\".... youcan #interval:duration of candles #count:how many candles you want to get from now to past #endtime:get candles from past to \"endtime\" sample \u00b6 from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption end_from_time = time . time () ANS = [] for i in range ( 70 ): data = Iq . get_candles ( \"EURUSD\" , 60 , 1000 , end_from_time ) ANS = data + ANS end_from_time = int ( data [ 0 ][ \"from\" ]) - 1 print ( ANS ) get realtime candles \u00b6 indicator sample \u00b6 from talib.abstract import * from iqoptionapi.stable_api import IQ_Option import time import numpy as np print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = 10 #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] timeperiod = 10 maxdict = 20 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) print ( \"Start EMA Sample\" ) while True : candles = Iq . get_realtime_candles ( goal , size ) inputs = { 'open' : np . array ([]), 'high' : np . array ([]), 'low' : np . array ([]), 'close' : np . array ([]), 'volume' : np . array ([]) } for timestamp in candles : inputs [ \"open\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"open\" ] ) inputs [ \"high\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"max\" ] ) inputs [ \"low\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"min\" ] ) inputs [ \"close\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"close\" ] ) inputs [ \"volume\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"volume\" ] ) print ( \"Show EMA\" ) print ( EMA ( inputs , timeperiod = timeperiod )) print ( \" \\n \" ) time . sleep ( 1 ) Iq . stop_candles_stream ( goal , size ) Sample \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) #DO something print ( \"Do something...\" ) time . sleep ( 10 ) print ( \"print candles\" ) cc = Iq . get_realtime_candles ( goal , size ) for k in cc : print ( goal , \"size\" , k , cc [ k ]) print ( \"stop candle\" ) Iq . stop_candles_stream ( goal , size ) size \u00b6 start_candles_stream() \u00b6 goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) get_realtime_candles() \u00b6 get_realtime_candles() after call start_candles_stream() Iq.get_realtime_candles(goal,size) stop_candles_stream() \u00b6 if you not using get_realtime_candles() anymore please close the stream Iq . stop_candles_stream ( goal , size )","title":"candle"},{"location":"en/candle/candle/#candle","text":"","title":"Candle"},{"location":"en/candle/candle/#get-candles","text":"only get close clndle, not realtime Iq.get_candles(ACTIVES,interval,count,endtime) #ACTIVES:sample input \"EURUSD\" OR \"EURGBP\".... youcan #interval:duration of candles #count:how many candles you want to get from now to past #endtime:get candles from past to \"endtime\"","title":"get candles"},{"location":"en/candle/candle/#sample","text":"from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption end_from_time = time . time () ANS = [] for i in range ( 70 ): data = Iq . get_candles ( \"EURUSD\" , 60 , 1000 , end_from_time ) ANS = data + ANS end_from_time = int ( data [ 0 ][ \"from\" ]) - 1 print ( ANS )","title":"sample"},{"location":"en/candle/candle/#get-realtime-candles","text":"","title":"get realtime candles"},{"location":"en/candle/candle/#indicator-sample","text":"from talib.abstract import * from iqoptionapi.stable_api import IQ_Option import time import numpy as np print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = 10 #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] timeperiod = 10 maxdict = 20 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) print ( \"Start EMA Sample\" ) while True : candles = Iq . get_realtime_candles ( goal , size ) inputs = { 'open' : np . array ([]), 'high' : np . array ([]), 'low' : np . array ([]), 'close' : np . array ([]), 'volume' : np . array ([]) } for timestamp in candles : inputs [ \"open\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"open\" ] ) inputs [ \"high\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"max\" ] ) inputs [ \"low\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"min\" ] ) inputs [ \"close\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"close\" ] ) inputs [ \"volume\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"volume\" ] ) print ( \"Show EMA\" ) print ( EMA ( inputs , timeperiod = timeperiod )) print ( \" \\n \" ) time . sleep ( 1 ) Iq . stop_candles_stream ( goal , size )","title":"indicator sample"},{"location":"en/candle/candle/#sample_1","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) #DO something print ( \"Do something...\" ) time . sleep ( 10 ) print ( \"print candles\" ) cc = Iq . get_realtime_candles ( goal , size ) for k in cc : print ( goal , \"size\" , k , cc [ k ]) print ( \"stop candle\" ) Iq . stop_candles_stream ( goal , size )","title":"Sample"},{"location":"en/candle/candle/#size","text":"","title":"size"},{"location":"en/candle/candle/#start_candles_stream","text":"goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict )","title":"start_candles_stream()"},{"location":"en/candle/candle/#get_realtime_candles","text":"get_realtime_candles() after call start_candles_stream() Iq.get_realtime_candles(goal,size)","title":"get_realtime_candles()"},{"location":"en/candle/candle/#stop_candles_stream","text":"if you not using get_realtime_candles() anymore please close the stream Iq . stop_candles_stream ( goal , size )","title":"stop_candles_stream()"},{"location":"en/digital/digital/","text":"Digital \u00b6 Nearest strike mode \u00b6 sample \u00b6 from iqoptionapi.stable_api import IQ_Option import time import random Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 Iq . subscribe_strike_list ( ACTIVES , duration ) #get strike_list data = Iq . get_realtime_strike_list ( ACTIVES , duration ) print ( \"get strike data\" ) print ( data ) \"\"\"data {'1.127100': { 'call': { 'profit': None, 'id': 'doEURUSD201811120649PT1MC11271' }, 'put': { 'profit': 566.6666666666666, 'id': 'doEURUSD201811120649PT1MP11271' } }............ } \"\"\" #get price list price_list = list ( data . keys ()) #random choose Strategy choose_price = price_list [ random . randint ( 0 , len ( price_list ) - 1 )] #get instrument_id instrument_id = data [ choose_price ][ \"call\" ][ \"id\" ] #get profit profit = data [ choose_price ][ \"call\" ][ \"profit\" ] print ( \"choose you want to buy\" ) print ( \"price:\" , choose_price , \"side:call\" , \"instrument_id:\" , instrument_id , \"profit:\" , profit ) #put instrument_id to buy buy_check , id = Iq . buy_digital ( amount , instrument_id ) polling_time = 5 if buy_check : print ( \"wait for check win\" ) #check win while True : check_close , win_money = Iq . check_win_digital_v2 ( id , polling_time ) if check_close : if float ( win_money ) > 0 : win_money = ( \" %.2f \" % ( win_money )) print ( \"you win\" , win_money , \"money\" ) else : print ( \"you loose\" ) break Iq . unsubscribe_strike_list ( ACTIVES , duration ) else : print ( \"fail to buy,please run again\" ) Get all strike list data \u00b6 smaple from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_realtime_strike_list ( ACTIVES , duration ) for price in data : print ( \"price\" , price , data [ price ]) time . sleep ( 5 ) Iq . unsubscribe_strike_list ( ACTIVES , duration ) subscribe_strike_list() \u00b6 Iq . subscribe_strike_list ( ACTIVES , duration ) get_realtime_strike_list \u00b6 you need call subscribe_strike_list() before get_realtime_strike_list() Iq . get_realtime_strike_list ( ACTIVES , duration ) unsubscribe_strike_list() \u00b6 Iq . unsubscribe_strike_list ( ACTIVES , duration ) buy_digital() \u00b6 buy_check , id = Iq . buy_digital ( amount , instrument_id ) #get instrument_id from Iq.get_realtime_strike_list Current price mode \u00b6 buy_digital_spot \u00b6 buy the digit in current price return check and id from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put print ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration )) get_digital_spot_profit_after_sale() \u00b6 get Profit After Sale(P/L) sample from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"passord\" ) ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 100 action = \"put\" #put Iq . subscribe_strike_list ( ACTIVES , duration ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : PL = Iq . get_digital_spot_profit_after_sale ( id ) if PL != None : print ( PL ) get_digital_current_profit() \u00b6 from iqoptionapi.stable_api import IQ_Option import time import logging #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_digital_current_profit ( ACTIVES , duration ) print ( data ) #from first print it may be get false,just wait a second you can get the profit time . sleep ( 1 ) Iq . unsubscribe_strike_list ( ACTIVES , duration ) check win for digital \u00b6 check_win_digital() \u00b6 this api is implement by get_digital_position() this function is polling , so need to set polling time Iq . check_win_digital ( id , polling_time ) #get the id from Iq.buy_digital check_win_digital_v2() \u00b6 this api is asynchronous get id data,it only can get id data before you call the buy action. if you restart the program,the asynchronous id data can not get again,so check_win_digital_v2 may not working,so you need to use \"check_win_digital\"! Iq . check_win_digital_v2 ( id ) #get the id from Iq.buy_digital #return:check_close,win_money #return sample #if you loose:Ture,o #if you win:True,1232.3 #if trade not clode yet:False,None sample code from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put _ , id = ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration )) print ( id ) if id != \"error\" : while True : check , win = Iq . check_win_digital_v2 ( id ) if check == True : break if win < 0 : print ( \"you loss \" + str ( win ) + \"$\" ) else : print ( \"you win \" + str ( win ) + \"$\" ) else : print ( \"please try again\" ) close_digital_option() \u00b6 Iq . close_digital_option ( id ) get digital data \u00b6 smaple1 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD-OTC\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put from datetime import datetime _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : check , _ = Iq . check_win_digital ( id ) if check : break print ( Iq . get_digital_position ( id )) print ( Iq . check_win_digital ( id )) sample2 print ( Iq . get_positions ( \"digital-option\" )) print ( Iq . get_digital_position ( 2323433 )) #in put the id print ( Iq . get_position_history ( \"digital-option\" ))","title":"Digital"},{"location":"en/digital/digital/#digital","text":"","title":"Digital"},{"location":"en/digital/digital/#nearest-strike-mode","text":"","title":"Nearest strike mode"},{"location":"en/digital/digital/#sample","text":"from iqoptionapi.stable_api import IQ_Option import time import random Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 Iq . subscribe_strike_list ( ACTIVES , duration ) #get strike_list data = Iq . get_realtime_strike_list ( ACTIVES , duration ) print ( \"get strike data\" ) print ( data ) \"\"\"data {'1.127100': { 'call': { 'profit': None, 'id': 'doEURUSD201811120649PT1MC11271' }, 'put': { 'profit': 566.6666666666666, 'id': 'doEURUSD201811120649PT1MP11271' } }............ } \"\"\" #get price list price_list = list ( data . keys ()) #random choose Strategy choose_price = price_list [ random . randint ( 0 , len ( price_list ) - 1 )] #get instrument_id instrument_id = data [ choose_price ][ \"call\" ][ \"id\" ] #get profit profit = data [ choose_price ][ \"call\" ][ \"profit\" ] print ( \"choose you want to buy\" ) print ( \"price:\" , choose_price , \"side:call\" , \"instrument_id:\" , instrument_id , \"profit:\" , profit ) #put instrument_id to buy buy_check , id = Iq . buy_digital ( amount , instrument_id ) polling_time = 5 if buy_check : print ( \"wait for check win\" ) #check win while True : check_close , win_money = Iq . check_win_digital_v2 ( id , polling_time ) if check_close : if float ( win_money ) > 0 : win_money = ( \" %.2f \" % ( win_money )) print ( \"you win\" , win_money , \"money\" ) else : print ( \"you loose\" ) break Iq . unsubscribe_strike_list ( ACTIVES , duration ) else : print ( \"fail to buy,please run again\" )","title":"sample"},{"location":"en/digital/digital/#get-all-strike-list-data","text":"smaple from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_realtime_strike_list ( ACTIVES , duration ) for price in data : print ( \"price\" , price , data [ price ]) time . sleep ( 5 ) Iq . unsubscribe_strike_list ( ACTIVES , duration )","title":"Get all strike list data"},{"location":"en/digital/digital/#subscribe_strike_list","text":"Iq . subscribe_strike_list ( ACTIVES , duration )","title":"subscribe_strike_list()"},{"location":"en/digital/digital/#get_realtime_strike_list","text":"you need call subscribe_strike_list() before get_realtime_strike_list() Iq . get_realtime_strike_list ( ACTIVES , duration )","title":"get_realtime_strike_list"},{"location":"en/digital/digital/#unsubscribe_strike_list","text":"Iq . unsubscribe_strike_list ( ACTIVES , duration )","title":"unsubscribe_strike_list()"},{"location":"en/digital/digital/#buy_digital","text":"buy_check , id = Iq . buy_digital ( amount , instrument_id ) #get instrument_id from Iq.get_realtime_strike_list","title":"buy_digital()"},{"location":"en/digital/digital/#current-price-mode","text":"","title":"Current price mode"},{"location":"en/digital/digital/#buy_digital_spot","text":"buy the digit in current price return check and id from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put print ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration ))","title":"buy_digital_spot"},{"location":"en/digital/digital/#get_digital_spot_profit_after_sale","text":"get Profit After Sale(P/L) sample from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"passord\" ) ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 100 action = \"put\" #put Iq . subscribe_strike_list ( ACTIVES , duration ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : PL = Iq . get_digital_spot_profit_after_sale ( id ) if PL != None : print ( PL )","title":"get_digital_spot_profit_after_sale()"},{"location":"en/digital/digital/#get_digital_current_profit","text":"from iqoptionapi.stable_api import IQ_Option import time import logging #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_digital_current_profit ( ACTIVES , duration ) print ( data ) #from first print it may be get false,just wait a second you can get the profit time . sleep ( 1 ) Iq . unsubscribe_strike_list ( ACTIVES , duration )","title":"get_digital_current_profit()"},{"location":"en/digital/digital/#check-win-for-digital","text":"","title":"check win for digital"},{"location":"en/digital/digital/#check_win_digital","text":"this api is implement by get_digital_position() this function is polling , so need to set polling time Iq . check_win_digital ( id , polling_time ) #get the id from Iq.buy_digital","title":"check_win_digital()"},{"location":"en/digital/digital/#check_win_digital_v2","text":"this api is asynchronous get id data,it only can get id data before you call the buy action. if you restart the program,the asynchronous id data can not get again,so check_win_digital_v2 may not working,so you need to use \"check_win_digital\"! Iq . check_win_digital_v2 ( id ) #get the id from Iq.buy_digital #return:check_close,win_money #return sample #if you loose:Ture,o #if you win:True,1232.3 #if trade not clode yet:False,None sample code from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put _ , id = ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration )) print ( id ) if id != \"error\" : while True : check , win = Iq . check_win_digital_v2 ( id ) if check == True : break if win < 0 : print ( \"you loss \" + str ( win ) + \"$\" ) else : print ( \"you win \" + str ( win ) + \"$\" ) else : print ( \"please try again\" )","title":"check_win_digital_v2()"},{"location":"en/digital/digital/#close_digital_option","text":"Iq . close_digital_option ( id )","title":"close_digital_option()"},{"location":"en/digital/digital/#get-digital-data","text":"smaple1 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD-OTC\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put from datetime import datetime _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : check , _ = Iq . check_win_digital ( id ) if check : break print ( Iq . get_digital_position ( id )) print ( Iq . check_win_digital ( id )) sample2 print ( Iq . get_positions ( \"digital-option\" )) print ( Iq . get_digital_position ( 2323433 )) #in put the id print ( Iq . get_position_history ( \"digital-option\" ))","title":"get digital data"},{"location":"en/fef/fef/","text":"Forex&Stock&Commodities&Crypto&ETFs \u00b6 instrument_type and instrument_id \u00b6 you can search instrument_type and instrument_id from this file search instrument_type and instrument_id sample \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" #input:\"buy\"/\"sell\" amount = 1.23 #input how many Amount you want to play #\"leverage\"=\"Multiplier\" leverage = 3 #you can get more information in get_available_leverages() type = \"market\" #input:\"market\"/\"limit\"/\"stop\" #for type=\"limit\"/\"stop\" # only working by set type=\"limit\" limit_price = None #input:None/value(float/int) # only working by set type=\"stop\" stop_price = None #input:None/value(float/int) #\"percent\"=Profit Percentage #\"price\"=Asset Price #\"diff\"=Profit in Money stop_lose_kind = \"percent\" #input:None/\"price\"/\"diff\"/\"percent\" stop_lose_value = 95 #input:None/value(float/int) take_profit_kind = None #input:None/\"price\"/\"diff\"/\"percent\" take_profit_value = None #input:None/value(float/int) #\"use_trail_stop\"=\"Trailing Stop\" use_trail_stop = True #True/False #\"auto_margin_call\"=\"Use Balance to Keep Position Open\" auto_margin_call = False #True/False #if you want \"take_profit_kind\"& # \"take_profit_value\"& # \"stop_lose_kind\"& # \"stop_lose_value\" all being \"Not Set\",\"auto_margin_call\" need to set:True use_token_for_commission = False #True/False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) print ( Iq . get_order ( order_id )) print ( Iq . get_positions ( \"crypto\" )) print ( Iq . get_position_history ( \"crypto\" )) print ( Iq . get_available_leverages ( \"crypto\" , \"BTCUSD\" )) print ( Iq . close_position ( order_id )) print ( Iq . get_overnight_fee ( \"crypto\" , \"BTCUSD\" )) buy_order() \u00b6 return (True/False,buy_order_id/False) if Buy sucess return (True,buy_order_id) \"percent\"=Profit Percentage \"price\"=Asset Price \"diff\"=Profit in Money parameter instrument_type instrument_type instrument_id instrument_id side \"buy\" \"sell\" amount value(float/int) leverage value(int) type \"market\" \"limit\" \"stop\" limit_price None value(float/int):Only working by set type=\"limit\" stop_price None value(float/int):Only working by set type=\"stop\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False use_token_for_commission True False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) change_order() \u00b6 ID_Name=\"\"order_id\" ID_Name=\"position_id\" parameter ID_Name \"position_id\" \"order_id\" order_id \"you need to get order_id from buy_order()\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False sample \u00b6 ID_Name = \"order_id\" #\"position_id\"/\"order_id\" stop_lose_kind = None stop_lose_value = None take_profit_kind = \"percent\" take_profit_value = 200 use_trail_stop = False auto_margin_call = True Iq . change_order ( ID_Name = ID_Name , order_id = order_id , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call ) get_order() \u00b6 get infomation about buy_order_id return (True/False,get_order,None) Iq . get_order ( buy_order_id ) get_pending() \u00b6 you will get there data Iq . get_pending ( instrument_type ) get_positions() \u00b6 you will get there data return (True/False,get_positions,None) not support \"\"turbo-option\"\" instrument_type=\"crypto\",\"forex\",\"fx-option\",\"multi-option\",\"cfd\",\"digital-option\" Iq . get_positions ( instrument_type ) get_position() \u00b6 you will get there data you will get one position by buy_order_id return (True/False,position data,None) Iq . get_positions ( buy_order_id ) get_position_history \u00b6 you will get there data get_position_history() \u00b6 return (True/False,position_history,None) Iq.get_position_history(instrument_type) get_position_history_v2 \u00b6 instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" get_position_history_v2(instrument_type,limit,offset,start,end) from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption #instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" instrument_type = \"digital-option\" limit = 2 #How many you want to get offset = 0 #offset from end time,if end time is 0,it mean get the data from now start = 0 #start time Timestamp end = 0 #Timestamp data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data ) #--------- this will get data start from 2019/7/1(end) to 2019/1/1(start) and only get 2(limit) data and offset is 0 instrument_type = \"digital-option\" limit = 2 #How many you want to get offset = 0 #offset from end time,if end time is 0,it mean get the data from now start = int ( time . mktime ( datetime . datetime . strptime ( \"2019/1/1\" , \"%Y/%m/ %d \" ) . timetuple ())) end = int ( time . mktime ( datetime . datetime . strptime ( \"2019/7/1\" , \"%Y/%m/ %d \" ) . timetuple ())) data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data ) get_available_leverages() \u00b6 get available leverages return (True/False,available_leverages,None) Iq . get_available_leverages ( instrument_type , actives ) cancel_order() \u00b6 you will do this return (True/False) Iq . cancel_order ( buy_order_id ) close_position() \u00b6 you will do this return (True/False) Iq . close_position ( buy_order_id ) get_overnight_fee() \u00b6 return (True/False,overnight_fee,None) Iq . get_overnight_fee ( instrument_type , active )","title":"Foreign exchange futures"},{"location":"en/fef/fef/#forexstockcommoditiescryptoetfs","text":"","title":"Forex&amp;Stock&amp;Commodities&amp;Crypto&amp;ETFs"},{"location":"en/fef/fef/#instrument_type-and-instrument_id","text":"you can search instrument_type and instrument_id from this file search instrument_type and instrument_id","title":"instrument_type and instrument_id"},{"location":"en/fef/fef/#sample","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" #input:\"buy\"/\"sell\" amount = 1.23 #input how many Amount you want to play #\"leverage\"=\"Multiplier\" leverage = 3 #you can get more information in get_available_leverages() type = \"market\" #input:\"market\"/\"limit\"/\"stop\" #for type=\"limit\"/\"stop\" # only working by set type=\"limit\" limit_price = None #input:None/value(float/int) # only working by set type=\"stop\" stop_price = None #input:None/value(float/int) #\"percent\"=Profit Percentage #\"price\"=Asset Price #\"diff\"=Profit in Money stop_lose_kind = \"percent\" #input:None/\"price\"/\"diff\"/\"percent\" stop_lose_value = 95 #input:None/value(float/int) take_profit_kind = None #input:None/\"price\"/\"diff\"/\"percent\" take_profit_value = None #input:None/value(float/int) #\"use_trail_stop\"=\"Trailing Stop\" use_trail_stop = True #True/False #\"auto_margin_call\"=\"Use Balance to Keep Position Open\" auto_margin_call = False #True/False #if you want \"take_profit_kind\"& # \"take_profit_value\"& # \"stop_lose_kind\"& # \"stop_lose_value\" all being \"Not Set\",\"auto_margin_call\" need to set:True use_token_for_commission = False #True/False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) print ( Iq . get_order ( order_id )) print ( Iq . get_positions ( \"crypto\" )) print ( Iq . get_position_history ( \"crypto\" )) print ( Iq . get_available_leverages ( \"crypto\" , \"BTCUSD\" )) print ( Iq . close_position ( order_id )) print ( Iq . get_overnight_fee ( \"crypto\" , \"BTCUSD\" ))","title":"sample"},{"location":"en/fef/fef/#buy_order","text":"return (True/False,buy_order_id/False) if Buy sucess return (True,buy_order_id) \"percent\"=Profit Percentage \"price\"=Asset Price \"diff\"=Profit in Money parameter instrument_type instrument_type instrument_id instrument_id side \"buy\" \"sell\" amount value(float/int) leverage value(int) type \"market\" \"limit\" \"stop\" limit_price None value(float/int):Only working by set type=\"limit\" stop_price None value(float/int):Only working by set type=\"stop\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False use_token_for_commission True False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission )","title":"buy_order()"},{"location":"en/fef/fef/#change_order","text":"ID_Name=\"\"order_id\" ID_Name=\"position_id\" parameter ID_Name \"position_id\" \"order_id\" order_id \"you need to get order_id from buy_order()\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False","title":"change_order()"},{"location":"en/fef/fef/#sample_1","text":"ID_Name = \"order_id\" #\"position_id\"/\"order_id\" stop_lose_kind = None stop_lose_value = None take_profit_kind = \"percent\" take_profit_value = 200 use_trail_stop = False auto_margin_call = True Iq . change_order ( ID_Name = ID_Name , order_id = order_id , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call )","title":"sample"},{"location":"en/fef/fef/#get_order","text":"get infomation about buy_order_id return (True/False,get_order,None) Iq . get_order ( buy_order_id )","title":"get_order()"},{"location":"en/fef/fef/#get_pending","text":"you will get there data Iq . get_pending ( instrument_type )","title":"get_pending()"},{"location":"en/fef/fef/#get_positions","text":"you will get there data return (True/False,get_positions,None) not support \"\"turbo-option\"\" instrument_type=\"crypto\",\"forex\",\"fx-option\",\"multi-option\",\"cfd\",\"digital-option\" Iq . get_positions ( instrument_type )","title":"get_positions()"},{"location":"en/fef/fef/#get_position","text":"you will get there data you will get one position by buy_order_id return (True/False,position data,None) Iq . get_positions ( buy_order_id )","title":"get_position()"},{"location":"en/fef/fef/#get_position_history","text":"you will get there data","title":"get_position_history"},{"location":"en/fef/fef/#get_position_history_1","text":"return (True/False,position_history,None) Iq.get_position_history(instrument_type)","title":"get_position_history()"},{"location":"en/fef/fef/#get_position_history_v2","text":"instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" get_position_history_v2(instrument_type,limit,offset,start,end) from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption #instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" instrument_type = \"digital-option\" limit = 2 #How many you want to get offset = 0 #offset from end time,if end time is 0,it mean get the data from now start = 0 #start time Timestamp end = 0 #Timestamp data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data ) #--------- this will get data start from 2019/7/1(end) to 2019/1/1(start) and only get 2(limit) data and offset is 0 instrument_type = \"digital-option\" limit = 2 #How many you want to get offset = 0 #offset from end time,if end time is 0,it mean get the data from now start = int ( time . mktime ( datetime . datetime . strptime ( \"2019/1/1\" , \"%Y/%m/ %d \" ) . timetuple ())) end = int ( time . mktime ( datetime . datetime . strptime ( \"2019/7/1\" , \"%Y/%m/ %d \" ) . timetuple ())) data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data )","title":"get_position_history_v2"},{"location":"en/fef/fef/#get_available_leverages","text":"get available leverages return (True/False,available_leverages,None) Iq . get_available_leverages ( instrument_type , actives )","title":"get_available_leverages()"},{"location":"en/fef/fef/#cancel_order","text":"you will do this return (True/False) Iq . cancel_order ( buy_order_id )","title":"cancel_order()"},{"location":"en/fef/fef/#close_position","text":"you will do this return (True/False) Iq . close_position ( buy_order_id )","title":"close_position()"},{"location":"en/fef/fef/#get_overnight_fee","text":"return (True/False,overnight_fee,None) Iq . get_overnight_fee ( instrument_type , active )","title":"get_overnight_fee()"},{"location":"en/techinical%20analysis/","text":"Tecnical analysis \u00b6 It is available in same assets and you can check it on asset info: if there is a session like this you can get data: NOTE: If there is no techinical Analysis on asset you want, you can't use it. There are some indicators available: Pivots \u00b6 Oscillators \u00b6 Moving Averages \u00b6 How to use: \u00b6 asset = \"GBPUSD\" indicators = Iq . get_technical_indicators ( asset ) print ( indicators ) if assets doesn't contains technical Analysis it returns: { \"code\": \"no_technical_indicator_available\", \"message\": \"Active is not supported: active id 'ACTIVE_ID_PASSED'\" } If there is something: NOTE: YOU MUST TO ANALYSE THE PRINT OUTPUT [ { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"OSCILLATORS\" , \"name\" : \"Relative Strength Index (14)\" , \"value\" : 59.168583 }, { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"PIVOTS\" , \"name\" : \"Classic s3\" , \"value\" : 1.057292 } ..... ]","title":"Techincal Analysis"},{"location":"en/techinical%20analysis/#tecnical-analysis","text":"It is available in same assets and you can check it on asset info: if there is a session like this you can get data: NOTE: If there is no techinical Analysis on asset you want, you can't use it. There are some indicators available:","title":"Tecnical analysis"},{"location":"en/techinical%20analysis/#pivots","text":"","title":"Pivots"},{"location":"en/techinical%20analysis/#oscillators","text":"","title":"Oscillators"},{"location":"en/techinical%20analysis/#moving-averages","text":"","title":"Moving Averages"},{"location":"en/techinical%20analysis/#how-to-use","text":"asset = \"GBPUSD\" indicators = Iq . get_technical_indicators ( asset ) print ( indicators ) if assets doesn't contains technical Analysis it returns: { \"code\": \"no_technical_indicator_available\", \"message\": \"Active is not supported: active id 'ACTIVE_ID_PASSED'\" } If there is something: NOTE: YOU MUST TO ANALYSE THE PRINT OUTPUT [ { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"OSCILLATORS\" , \"name\" : \"Relative Strength Index (14)\" , \"value\" : 59.168583 }, { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"PIVOTS\" , \"name\" : \"Classic s3\" , \"value\" : 1.057292 } ..... ]","title":"How to use:"},{"location":"es/","text":"Primeros pasos \u00b6 Instalar iqoptionapi \u00b6 descarga el c\u00f3digo fuente y ejecuta lo siguiente: python setup.py install o instalar usando (Necesitas git instalada ): pip install -U git+git://github.com/iqoptionapi/iqoptionapi.git Un ejemplo simple \u00b6 import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ())) Importar la librer\u00eda \u00b6 from iqoptionapi.stable_api import IQ_Option Login \u00b6 Iq.connect() will return (check,reason) Si la conexi\u00f3n es exitosa, devuelve -> True,None Si hay alg\u00fan fallo en la conexi\u00f3n, devuelve -> False,reason from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) check , reason = Iq . connect () #connect to iqoption print ( check , reason ) Activar el modo Debug \u00b6 import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Conectarse y comprobar la conexi\u00f3n \u00b6 A veces la conexi\u00f3n se cierra, as\u00ed que debemos de comprobar la conexi\u00f3n y volvenos a conectar. Prueba a desconectar tu conexi\u00f3n y volverla a conectar para probar el siguiente ejemplo. from iqoptionapi.stable_api import IQ_Option error_password = \"\"\"{\"code\":\"invalid_credentials\",\"message\":\"You entered the wrong credentials. Please check that the login/password is correct.\"}\"\"\" iqoption = IQ_Option ( \"email\" , \"password\" ) check , reason = iqoption . connect () if check : print ( \"Activa tu robot\" ) #Si ves esto puedess cerrar la conexi\u00f3n para probarlo while True : if iqoption . check_connect () == False : #Detecta si el websocket ha sido cerrado print ( \"Probando a reconectar\" ) check , reason = iqoption . connect () if check : print ( \"Reconectado con \u00e9xito\" ) else : if reason == error_password : print ( \"Contrase\u00f1a incorrecta\" ) else : print ( \"No hay conexi\u00f3n\" ) else : if reason == \"[Errno -2] Nombre or servicio no conocido\" : print ( \"No hay conexi\u00f3n\" ) elif reason == error_password : print ( \"Error en la Contrase\u00f1a\" ) set_session \u00b6 Default User-Agent is \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) #Por defecto es \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" header = { \"User-Agent\" : r \"Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0\" } cookie = { \"Iq\" : \"GOOD\" } Iq . set_session ( header , cookie ) Iq . connect () #Conectar a IqOption Comprobar versi\u00f3n \u00b6 from iqoptionapi.stable_api import IQ_Option print ( IQ_Option . __version__ ) Comprobar conexi\u00f3n \u00b6 return True/False print(Iq.check_connect()) Reconnect \u00b6 Iq . connect () time \u00b6 get_server_timestamp El tiempo se sincronica con iqoption Iq . get_server_timestamp ()","title":"Empezar"},{"location":"es/#primeros-pasos","text":"","title":"Primeros pasos"},{"location":"es/#instalar-iqoptionapi","text":"descarga el c\u00f3digo fuente y ejecuta lo siguiente: python setup.py install o instalar usando (Necesitas git instalada ): pip install -U git+git://github.com/iqoptionapi/iqoptionapi.git","title":"Instalar iqoptionapi"},{"location":"es/#un-ejemplo-simple","text":"import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ()))","title":"Un ejemplo simple"},{"location":"es/#importar-la-libreria","text":"from iqoptionapi.stable_api import IQ_Option","title":"Importar la librer\u00eda"},{"location":"es/#login","text":"Iq.connect() will return (check,reason) Si la conexi\u00f3n es exitosa, devuelve -> True,None Si hay alg\u00fan fallo en la conexi\u00f3n, devuelve -> False,reason from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) check , reason = Iq . connect () #connect to iqoption print ( check , reason )","title":"Login"},{"location":"es/#activar-el-modo-debug","text":"import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' )","title":"Activar el modo Debug"},{"location":"es/#conectarse-y-comprobar-la-conexion","text":"A veces la conexi\u00f3n se cierra, as\u00ed que debemos de comprobar la conexi\u00f3n y volvenos a conectar. Prueba a desconectar tu conexi\u00f3n y volverla a conectar para probar el siguiente ejemplo. from iqoptionapi.stable_api import IQ_Option error_password = \"\"\"{\"code\":\"invalid_credentials\",\"message\":\"You entered the wrong credentials. Please check that the login/password is correct.\"}\"\"\" iqoption = IQ_Option ( \"email\" , \"password\" ) check , reason = iqoption . connect () if check : print ( \"Activa tu robot\" ) #Si ves esto puedess cerrar la conexi\u00f3n para probarlo while True : if iqoption . check_connect () == False : #Detecta si el websocket ha sido cerrado print ( \"Probando a reconectar\" ) check , reason = iqoption . connect () if check : print ( \"Reconectado con \u00e9xito\" ) else : if reason == error_password : print ( \"Contrase\u00f1a incorrecta\" ) else : print ( \"No hay conexi\u00f3n\" ) else : if reason == \"[Errno -2] Nombre or servicio no conocido\" : print ( \"No hay conexi\u00f3n\" ) elif reason == error_password : print ( \"Error en la Contrase\u00f1a\" )","title":"Conectarse y comprobar la conexi\u00f3n"},{"location":"es/#set_session","text":"Default User-Agent is \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" from iqoptionapi.stable_api import IQ_Option import logging logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) #Por defecto es \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" header = { \"User-Agent\" : r \"Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0\" } cookie = { \"Iq\" : \"GOOD\" } Iq . set_session ( header , cookie ) Iq . connect () #Conectar a IqOption","title":"set_session"},{"location":"es/#comprobar-version","text":"from iqoptionapi.stable_api import IQ_Option print ( IQ_Option . __version__ )","title":"Comprobar versi\u00f3n"},{"location":"es/#comprobar-conexion","text":"return True/False print(Iq.check_connect())","title":"Comprobar conexi\u00f3n"},{"location":"es/#reconnect","text":"Iq . connect ()","title":"Reconnect"},{"location":"es/#time","text":"get_server_timestamp El tiempo se sincronica con iqoption Iq . get_server_timestamp ()","title":"time"},{"location":"es/account/account/","text":"Cuenta \u00b6 get_balance() \u00b6 Obt\u00e9n el saldo de tu cuenta Iq . get_balance () get_balance_v2() \u00b6 Obt\u00e9n el saldo de tu cuenta con M\u00c1S PRECISI\u00d3N Iq . get_balance_v2 () get_currency() \u00b6 Comprobar que divisa utiliza tu cuenta (USD, EUR...) Iq . get_currency () reset_practice_balance() \u00b6 Recargar el saldo de tu cuenta de pr\u00e1ctica a $10000 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption print ( Iq . reset_practice_balance ()) Cambiar tu cuenta entre los smodos Real/Pr\u00e1ctica \u00b6 MODE=\"PRACTICE\"/\"REAL\" Iq . change_balance ( MODE ) #MODE: \"PRACTICE\"/\"REAL\" obtener la Estrat\u00e9gia de Otra Gente \u00b6 Ejemplo \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #Para opciones digitales name = \"live-deal-digital-option\" #\"live-deal-binary-option-placed\"/\"live-deal-digital-option\" active = \"EURUSD\" _type = \"PT1M\" #\"PT1M\"/\"PT5M\"/\"PT15M\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_digital_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) #Para opciones binariass name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_binary_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) subscribe_live_deal \u00b6 Suscribirse a un acuerdo en vivo Iq . subscribe_live_deal ( name , active , _type , buffersize ) unscribe_live_deal \u00b6 Cancelar suscripci\u00f3n al acuerdo en vivo Iq . unscribe_live_deal ( name , active , _type ) get_live_deal \u00b6 Obtener el acuerdo en vivo Iq . get_live_deal ( name , active , _type ) pop_live_deal \u00b6 Iq . pop_live_deal ( name , active , _type ) get Other people detail \u00b6 Obtener los detalles de otra gente Ejemplo \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #Para opciones binarias name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) print ( \" \\n\\n \" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) last_trade_data = Iq . get_live_deal ( name , active , _type )[ 0 ] user_id = last_trade_data [ \"user_id\" ] counutry_id = last_trade_data [ \"country_id\" ] print ( \"_______get_user_profile_client__________\" ) print ( Iq . get_user_profile_client ( user_id )) pro_data = Iq . get_user_profile_client ( user_id ) print ( \" \\n\\n \" ) print ( \"___________request_leaderboard_userinfo_deals_client______\" ) print ( Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id )) user_data = Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id ) worldwide = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"position\" ] profit = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"score\" ] print ( \" \\n \" ) print ( \"user_name:\" + pro_data [ \"user_name\" ]) print ( \"Esta semana en todo el mundo: \" + str ( worldwide )) print ( \"Esta semana beneficios en bruto: \" + str ( profit )) print ( \" \\n\\n \" ) print ( \"___________get_users_availability____________\" ) print ( Iq . get_users_availability ( user_id )) print ( \" \\n\\n \" ) print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) get_user_profile_client() \u00b6 Obtener el nombre de usuario y imagen Iq . get_user_profile_client ( user_id ) request_leaderboard_userinfo_deals_client() \u00b6 Obtener los detalles del cliente Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id ) get_users_availability() \u00b6 Iq . get_users_availability ( user_id )","title":"Cuenta"},{"location":"es/account/account/#cuenta","text":"","title":"Cuenta"},{"location":"es/account/account/#get_balance","text":"Obt\u00e9n el saldo de tu cuenta Iq . get_balance ()","title":"get_balance()"},{"location":"es/account/account/#get_balance_v2","text":"Obt\u00e9n el saldo de tu cuenta con M\u00c1S PRECISI\u00d3N Iq . get_balance_v2 ()","title":"get_balance_v2()"},{"location":"es/account/account/#get_currency","text":"Comprobar que divisa utiliza tu cuenta (USD, EUR...) Iq . get_currency ()","title":"get_currency()"},{"location":"es/account/account/#reset_practice_balance","text":"Recargar el saldo de tu cuenta de pr\u00e1ctica a $10000 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption print ( Iq . reset_practice_balance ())","title":"reset_practice_balance()"},{"location":"es/account/account/#cambiar-tu-cuenta-entre-los-smodos-realpractica","text":"MODE=\"PRACTICE\"/\"REAL\" Iq . change_balance ( MODE ) #MODE: \"PRACTICE\"/\"REAL\"","title":"Cambiar tu cuenta entre los smodos Real/Pr\u00e1ctica"},{"location":"es/account/account/#obtener-la-estrategia-de-otra-gente","text":"","title":"obtener la Estrat\u00e9gia de Otra Gente"},{"location":"es/account/account/#ejemplo","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #Para opciones digitales name = \"live-deal-digital-option\" #\"live-deal-binary-option-placed\"/\"live-deal-digital-option\" active = \"EURUSD\" _type = \"PT1M\" #\"PT1M\"/\"PT5M\"/\"PT15M\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_digital_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type ) #Para opciones binariass name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) start_t = time . time () while True : data = ( Iq . get_live_deal ( name , active , _type )) print ( \"__For_binary_option__ data size:\" + str ( len ( data ))) print ( data ) print ( \" \\n\\n \" ) time . sleep ( 1 ) if time . time () - start_t > while_run_time : break print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type )","title":"Ejemplo"},{"location":"es/account/account/#subscribe_live_deal","text":"Suscribirse a un acuerdo en vivo Iq . subscribe_live_deal ( name , active , _type , buffersize )","title":"subscribe_live_deal"},{"location":"es/account/account/#unscribe_live_deal","text":"Cancelar suscripci\u00f3n al acuerdo en vivo Iq . unscribe_live_deal ( name , active , _type )","title":"unscribe_live_deal"},{"location":"es/account/account/#get_live_deal","text":"Obtener el acuerdo en vivo Iq . get_live_deal ( name , active , _type )","title":"get_live_deal"},{"location":"es/account/account/#pop_live_deal","text":"Iq . pop_live_deal ( name , active , _type )","title":"pop_live_deal"},{"location":"es/account/account/#get-other-people-detail","text":"Obtener los detalles de otra gente","title":"get Other people detail"},{"location":"es/account/account/#ejemplo_1","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption while_run_time = 10 #Para opciones binarias name = \"live-deal-binary-option-placed\" active = \"EURUSD\" _type = \"turbo\" #\"turbo\"/\"binary\" buffersize = 10 # print ( \"_____________subscribe_live_deal_______________\" ) print ( \" \\n\\n \" ) Iq . subscribe_live_deal ( name , active , _type , buffersize ) last_trade_data = Iq . get_live_deal ( name , active , _type )[ 0 ] user_id = last_trade_data [ \"user_id\" ] counutry_id = last_trade_data [ \"country_id\" ] print ( \"_______get_user_profile_client__________\" ) print ( Iq . get_user_profile_client ( user_id )) pro_data = Iq . get_user_profile_client ( user_id ) print ( \" \\n\\n \" ) print ( \"___________request_leaderboard_userinfo_deals_client______\" ) print ( Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id )) user_data = Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id ) worldwide = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"position\" ] profit = user_data [ \"result\" ][ \"entries_by_country\" ][ \"0\" ][ \"score\" ] print ( \" \\n \" ) print ( \"user_name:\" + pro_data [ \"user_name\" ]) print ( \"Esta semana en todo el mundo: \" + str ( worldwide )) print ( \"Esta semana beneficios en bruto: \" + str ( profit )) print ( \" \\n\\n \" ) print ( \"___________get_users_availability____________\" ) print ( Iq . get_users_availability ( user_id )) print ( \" \\n\\n \" ) print ( \"_____________unscribe_live_deal_______________\" ) Iq . unscribe_live_deal ( name , active , _type )","title":"Ejemplo"},{"location":"es/account/account/#get_user_profile_client","text":"Obtener el nombre de usuario y imagen Iq . get_user_profile_client ( user_id )","title":"get_user_profile_client()"},{"location":"es/account/account/#request_leaderboard_userinfo_deals_client","text":"Obtener los detalles del cliente Iq . request_leaderboard_userinfo_deals_client ( user_id , counutry_id )","title":"request_leaderboard_userinfo_deals_client()"},{"location":"es/account/account/#get_users_availability","text":"Iq . get_users_availability ( user_id )","title":"get_users_availability()"},{"location":"es/all/all/","text":"Para todo \u00b6 Esta api puede trabajar con option&digital&Forex&Stock&Commodities&Crypto&ETFs Comprobar si un asset est\u00e1 abierto o no \u00b6 tener cuidado con get_all_open_time() es demasiado pesado para la conexi\u00f3n. get_all_open_time() devuelve un DICT \"cfd\" incluye,Commodities,ETFs asset DICT[\"forex\"/\"cfd\"/\"crypto\"/\"digital\"/\"turbo\"/\"binary\"][Asset Name][\"open\"] devolver\u00e1 True/False from iqoptionapi.stable_api import IQ_Option import logging import random logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ALL_Asset = Iq . get_all_open_time () #Comprobar si est\u00e1 abierto o no print ( ALL_Asset [ \"forex\" ][ \"EURUSD\" ][ \"open\" ]) print ( ALL_Asset [ \"cfd\" ][ \"FACEBOOK\" ][ \"open\" ]) #Stock,Commodities,ETFs print ( ALL_Asset [ \"crypto\" ][ \"BTCUSD-L\" ][ \"open\" ]) print ( ALL_Asset [ \"digital\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #La binarias tienes doss tipos -> type:\"turbo\",\"binary\" print ( ALL_Asset [ \"turbo\" ][ \"EURUSD-OTC\" ][ \"open\" ]) print ( ALL_Asset [ \"binary\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #!!!! Excepci\u00f3j \"\" print ( ALL_Asset [ \"binary\" ][ \"not exist asset\" ][ \"open\" ]) #Devolver\u00e1 \"{}\" a None de un dict #!!!!Imprimir todo!!! for type_name , data in ALL_Asset . items (): for Asset , value in data . items (): print ( type_name , Asset , value [ \"open\" ]) Ver todos los nombress de lo Activos (ACTIVES) \u00b6 print(Iq.get_all_ACTIVES_OPCODE()) Actualizar OPCODE de los Activos (ACTIVES) \u00b6 Iq.update_ACTIVES_OPCODE() get_async_order() \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put print ( \"__Para_Opciones_Binarias__\" ) _ , id = Iq . buy ( amount , ACTIVES , action , duration ) while Iq . get_async_order ( id ) == None : pass print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__Para_Opciones_Digitales__spot\" ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__Para_Forex_Mercado_MateriasPrimas_Crypto_ETFs\" ) instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" amount = 1.23 leverage = 3 type = \"market\" limit_price = None stop_price = None stop_lose_kind = \"percent\" stop_lose_value = 95 take_profit_kind = None take_profit_value = None use_trail_stop = True auto_margin_call = False use_token_for_commission = False check , id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id )) get_commission_change() \u00b6 instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" Iq.subscribe_commission_changed(instrument_type) Iq.get_commission_change(instrument_type) Iq.unsubscribe_commission_changed(instrument_type) C\u00f3digo de ejemplo import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption #instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" instrument_type = [ \"binary-option\" , \"turbo-option\" , \"digital-option\" , \"crypto\" , \"forex\" , \"cfd\" ] for ins in instrument_type : Iq . subscribe_commission_changed ( ins ) print ( \"Start stream please wait profit change...\" ) while True : for ins in instrument_type : commissio_data = Iq . get_commission_change ( ins ) if commissio_data != {}: for active_name in commissio_data : if commissio_data [ active_name ] != {}: the_min_timestamp = min ( commissio_data [ active_name ] . keys ()) commissio = commissio_data [ active_name ][ the_min_timestamp ] profit = ( 100 - commissio ) / 100 print ( \"instrument_type: \" + str ( ins ) + \" active_name: \" + str ( active_name ) + \" profit change to: \" + str ( profit )) #Data have been update so need del del Iq . get_commission_change ( ins )[ active_name ][ the_min_timestamp ] time . sleep ( 1 ) Obtener top_assets_updated \u00b6 Ejemplo \u00b6 instrument_type=\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : print ( Iq . get_top_assets_updated ( instrument_type )) print ( \" \\n\\n \" ) time . sleep ( 1 ) Iq . unsubscribe_top_assets_updated ( instrument_type ) subscribe_top_assets_updated() \u00b6 instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) get_top_assets_updated() \u00b6 se necesista llamar a get_top_assets_updated() despu\u00e9s de subscribe_top_assets_updated() Iq . get_top_assets_updated ( instrument_type ) unsubscribe_top_assets_updated() \u00b6 Si no vas a uarlo, ci\u00e9rralo para una conexi\u00f3n sesgura Iq . unsubscribe_top_assets_updated ( instrument_type ) orderar par popularidad \u00b6 Ejemplo \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time import operator #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') def opcode_to_name ( opcode_data , opcode ): return list ( opcode_data . keys ())[ list ( opcode_data . values ()) . index ( opcode )] Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Iq . update_ACTIVES_OPCODE () opcode_data = Iq . get_all_ACTIVES_OPCODE () instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : break top_assets = Iq . get_top_assets_updated ( instrument_type ) popularity = {} for asset in top_assets : opcode = asset [ \"active_id\" ] popularity_value = asset [ \"popularity\" ][ \"value\" ] try : name = opcode_to_name ( opcode_data , opcode ) popularity [ name ] = popularity_value except : pass sorted_popularity = sorted ( popularity . items (), key = operator . itemgetter ( 1 )) print ( \"__Popularidad_min_to_max__\" ) for lis in sorted_popularity : print ( lis ) Iq . unsubscribe_top_assets_updated ( instrument_type ) get_leader_board \u00b6 Obtener el ranking the l\u00edders from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( email , password ) Iq . connect () #connect to iqoption country = \"TW\" from_position = 1 to_position = 1 near_traders_count = 0 print ( Iq . get_leader_board ( country , from_position , to_position , near_traders_count )) Country ID = {\"Worldwide\":0, \"AF\": 1, \"AL\": 2, \"DZ\": 3, \"AD\": 5, \"AO\": 6, \"AI\": 7, \"AG\": 9, \"AR\": 10, \"AM\": 11, \"AW\": 12, \"AT\": 14, \"AZ\": 15, \"BS\": 16, \"BH\": 17, \"BD\": 18, \"BB\": 19, \"BY\": 20, \"BZ\": 22, \"BJ\": 23, \"BM\": 24, \"BO\": 26, \"BA\": 27, \"BW\": 28, \"BV\": 29, \"BR\": 30, \"BN\": 31, \"BG\": 32, \"BF\": 33, \"BI\": 34, \"KH\": 35, \"CM\": 36, \"CV\": 38, \"KY\": 39, \"TD\": 41, \"CL\": 42, \"CN\": 43, \"CC\": 45, \"CO\": 46, \"KM\": 47, \"CG\": 48, \"CK\": 49, \"CR\": 50, \"CI\": 51, \"HR\": 52, \"CU\": 53, \"CY\": 54, \"CZ\": 55, \"DK\": 56, \"DJ\": 57, \"DM\": 58, \"DO\": 59, \"TL\": 60, \"EC\": 61, \"EG\": 62, \"SV\": 63, \"EE\": 66, \"ET\": 67, \"FO\": 69, \"FJ\": 70, \"FI\": 71, \"FR\": 72, \"GF\": 73, \"PF\": 74, \"GA\": 75, \"GM\": 76, \"GE\": 77, \"DE\": 78, \"GH\": 79, \"GR\": 81, \"GD\": 83, \"GP\": 84, \"GT\": 86, \"GN\": 87, \"GY\": 88, \"HT\": 89, \"HN\": 90, \"HK\": 91, \"HU\": 92, \"IS\": 93, \"ID\": 94, \"IQ\": 95, \"IE\": 96, \"IT\": 97, \"JM\": 98, \"JO\": 100, \"KZ\": 101, \"KE\": 102, \"KI\": 103, \"KW\": 104, \"KG\": 105, \"LA\": 106, \"LV\": 107, \"LB\": 108, \"LS\": 109, \"LR\": 110, \"LY\": 111, \"LT\": 113, \"LU\": 114, \"MO\": 115, \"MK\": 116, \"MG\": 117, \"MW\": 118, \"MY\": 119, \"MV\": 120, \"ML\": 121, \"MT\": 122, \"MQ\": 124, \"MR\": 125, \"MU\": 126, \"MX\": 128, \"FM\": 129, \"MD\": 130, \"MC\": 131, \"MN\": 132, \"MA\": 134, \"MZ\": 135, \"MM\": 136, \"NA\": 137, \"NP\": 139, \"NL\": 140, \"AN\": 141, \"NC\": 142, \"NZ\": 143, \"NI\": 144, \"NE\": 145, \"NG\": 146, \"NO\": 149, \"OM\": 150, \"PK\": 151, \"PW\": 152, \"PA\": 153, \"PG\": 154, \"PY\": 155, \"PE\": 156, \"PH\": 157, \"PL\": 159, \"PT\": 160, \"QA\": 162, \"RE\": 163, \"RO\": 164, \"RW\": 166, \"KN\": 167, \"LC\": 168, \"SA\": 171, \"SN\": 172, \"SC\": 173, \"SG\": 175, \"SK\": 176, \"SI\": 177, \"SO\": 179, \"ZA\": 180, \"KR\": 181, \"ES\": 182, \"LK\": 183, \"SH\": 184, \"SR\": 186, \"SZ\": 187, \"SE\": 188, \"CH\": 189, \"TW\": 191, \"TJ\": 192, \"TZ\": 193, \"TH\": 194, \"TG\": 195, \"TT\": 198, \"TN\": 199, \"TR\": 200, \"TM\": 201, \"UG\": 203, \"UA\": 204, \"AE\": 205, \"GB\": 206, \"UY\": 207, \"UZ\": 208, \"VE\": 211, \"VN\": 212, \"VG\": 213, \"YE\": 216, \"ZM\": 218, \"ZW\": 219, \"RS\": 220, \"ME\": 221, \"IN\": 225, \"TC\": 234, \"CD\": 235, \"GG\": 236, \"IM\": 237, \"JE\": 239, \"CW\": 246, }","title":"Para todo"},{"location":"es/all/all/#para-todo","text":"Esta api puede trabajar con option&digital&Forex&Stock&Commodities&Crypto&ETFs","title":"Para todo"},{"location":"es/all/all/#comprobar-si-un-asset-esta-abierto-o-no","text":"tener cuidado con get_all_open_time() es demasiado pesado para la conexi\u00f3n. get_all_open_time() devuelve un DICT \"cfd\" incluye,Commodities,ETFs asset DICT[\"forex\"/\"cfd\"/\"crypto\"/\"digital\"/\"turbo\"/\"binary\"][Asset Name][\"open\"] devolver\u00e1 True/False from iqoptionapi.stable_api import IQ_Option import logging import random logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ALL_Asset = Iq . get_all_open_time () #Comprobar si est\u00e1 abierto o no print ( ALL_Asset [ \"forex\" ][ \"EURUSD\" ][ \"open\" ]) print ( ALL_Asset [ \"cfd\" ][ \"FACEBOOK\" ][ \"open\" ]) #Stock,Commodities,ETFs print ( ALL_Asset [ \"crypto\" ][ \"BTCUSD-L\" ][ \"open\" ]) print ( ALL_Asset [ \"digital\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #La binarias tienes doss tipos -> type:\"turbo\",\"binary\" print ( ALL_Asset [ \"turbo\" ][ \"EURUSD-OTC\" ][ \"open\" ]) print ( ALL_Asset [ \"binary\" ][ \"EURUSD-OTC\" ][ \"open\" ]) #!!!! Excepci\u00f3j \"\" print ( ALL_Asset [ \"binary\" ][ \"not exist asset\" ][ \"open\" ]) #Devolver\u00e1 \"{}\" a None de un dict #!!!!Imprimir todo!!! for type_name , data in ALL_Asset . items (): for Asset , value in data . items (): print ( type_name , Asset , value [ \"open\" ])","title":"Comprobar si un asset est\u00e1 abierto o no"},{"location":"es/all/all/#ver-todos-los-nombress-de-lo-activos-actives","text":"print(Iq.get_all_ACTIVES_OPCODE())","title":"Ver todos los nombress de lo Activos (ACTIVES)"},{"location":"es/all/all/#actualizar-opcode-de-los-activos-actives","text":"Iq.update_ACTIVES_OPCODE()","title":"Actualizar OPCODE de los Activos (ACTIVES)"},{"location":"es/all/all/#get_async_order","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 1 action = \"call\" #put print ( \"__Para_Opciones_Binarias__\" ) _ , id = Iq . buy ( amount , ACTIVES , action , duration ) while Iq . get_async_order ( id ) == None : pass print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__Para_Opciones_Digitales__spot\" ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id )) print ( \" \\n\\n \" ) print ( \"__Para_Forex_Mercado_MateriasPrimas_Crypto_ETFs\" ) instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" amount = 1.23 leverage = 3 type = \"market\" limit_price = None stop_price = None stop_lose_kind = \"percent\" stop_lose_value = 95 take_profit_kind = None take_profit_value = None use_trail_stop = True auto_margin_call = False use_token_for_commission = False check , id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) while Iq . get_async_order ( id ) == None : pass order_data = Iq . get_async_order ( id ) print ( Iq . get_async_order ( id ))","title":"get_async_order()"},{"location":"es/all/all/#get_commission_change","text":"instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" Iq.subscribe_commission_changed(instrument_type) Iq.get_commission_change(instrument_type) Iq.unsubscribe_commission_changed(instrument_type) C\u00f3digo de ejemplo import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption #instrument_type: \"binary-option\"/\"turbo-option\"/\"digital-option\"/\"crypto\"/\"forex\"/\"cfd\" instrument_type = [ \"binary-option\" , \"turbo-option\" , \"digital-option\" , \"crypto\" , \"forex\" , \"cfd\" ] for ins in instrument_type : Iq . subscribe_commission_changed ( ins ) print ( \"Start stream please wait profit change...\" ) while True : for ins in instrument_type : commissio_data = Iq . get_commission_change ( ins ) if commissio_data != {}: for active_name in commissio_data : if commissio_data [ active_name ] != {}: the_min_timestamp = min ( commissio_data [ active_name ] . keys ()) commissio = commissio_data [ active_name ][ the_min_timestamp ] profit = ( 100 - commissio ) / 100 print ( \"instrument_type: \" + str ( ins ) + \" active_name: \" + str ( active_name ) + \" profit change to: \" + str ( profit )) #Data have been update so need del del Iq . get_commission_change ( ins )[ active_name ][ the_min_timestamp ] time . sleep ( 1 )","title":"get_commission_change()"},{"location":"es/all/all/#obtener-top_assets_updated","text":"","title":"Obtener top_assets_updated"},{"location":"es/all/all/#ejemplo","text":"instrument_type=\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : print ( Iq . get_top_assets_updated ( instrument_type )) print ( \" \\n\\n \" ) time . sleep ( 1 ) Iq . unsubscribe_top_assets_updated ( instrument_type )","title":"Ejemplo"},{"location":"es/all/all/#subscribe_top_assets_updated","text":"instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type )","title":"subscribe_top_assets_updated()"},{"location":"es/all/all/#get_top_assets_updated","text":"se necesista llamar a get_top_assets_updated() despu\u00e9s de subscribe_top_assets_updated() Iq . get_top_assets_updated ( instrument_type )","title":"get_top_assets_updated()"},{"location":"es/all/all/#unsubscribe_top_assets_updated","text":"Si no vas a uarlo, ci\u00e9rralo para una conexi\u00f3n sesgura Iq . unsubscribe_top_assets_updated ( instrument_type )","title":"unsubscribe_top_assets_updated()"},{"location":"es/all/all/#orderar-par-popularidad","text":"","title":"orderar par popularidad"},{"location":"es/all/all/#ejemplo_1","text":"from iqoptionapi.stable_api import IQ_Option import logging import time import operator #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') def opcode_to_name ( opcode_data , opcode ): return list ( opcode_data . keys ())[ list ( opcode_data . values ()) . index ( opcode )] Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption Iq . update_ACTIVES_OPCODE () opcode_data = Iq . get_all_ACTIVES_OPCODE () instrument_type = \"digital-option\" #\"binary-option\"/\"digital-option\"/\"forex\"/\"cfd\"/\"crypto\" Iq . subscribe_top_assets_updated ( instrument_type ) print ( \"__Please_wait_for_sec__\" ) while True : if Iq . get_top_assets_updated ( instrument_type ) != None : break top_assets = Iq . get_top_assets_updated ( instrument_type ) popularity = {} for asset in top_assets : opcode = asset [ \"active_id\" ] popularity_value = asset [ \"popularity\" ][ \"value\" ] try : name = opcode_to_name ( opcode_data , opcode ) popularity [ name ] = popularity_value except : pass sorted_popularity = sorted ( popularity . items (), key = operator . itemgetter ( 1 )) print ( \"__Popularidad_min_to_max__\" ) for lis in sorted_popularity : print ( lis ) Iq . unsubscribe_top_assets_updated ( instrument_type )","title":"Ejemplo"},{"location":"es/all/all/#get_leader_board","text":"Obtener el ranking the l\u00edders from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( email , password ) Iq . connect () #connect to iqoption country = \"TW\" from_position = 1 to_position = 1 near_traders_count = 0 print ( Iq . get_leader_board ( country , from_position , to_position , near_traders_count )) Country ID = {\"Worldwide\":0, \"AF\": 1, \"AL\": 2, \"DZ\": 3, \"AD\": 5, \"AO\": 6, \"AI\": 7, \"AG\": 9, \"AR\": 10, \"AM\": 11, \"AW\": 12, \"AT\": 14, \"AZ\": 15, \"BS\": 16, \"BH\": 17, \"BD\": 18, \"BB\": 19, \"BY\": 20, \"BZ\": 22, \"BJ\": 23, \"BM\": 24, \"BO\": 26, \"BA\": 27, \"BW\": 28, \"BV\": 29, \"BR\": 30, \"BN\": 31, \"BG\": 32, \"BF\": 33, \"BI\": 34, \"KH\": 35, \"CM\": 36, \"CV\": 38, \"KY\": 39, \"TD\": 41, \"CL\": 42, \"CN\": 43, \"CC\": 45, \"CO\": 46, \"KM\": 47, \"CG\": 48, \"CK\": 49, \"CR\": 50, \"CI\": 51, \"HR\": 52, \"CU\": 53, \"CY\": 54, \"CZ\": 55, \"DK\": 56, \"DJ\": 57, \"DM\": 58, \"DO\": 59, \"TL\": 60, \"EC\": 61, \"EG\": 62, \"SV\": 63, \"EE\": 66, \"ET\": 67, \"FO\": 69, \"FJ\": 70, \"FI\": 71, \"FR\": 72, \"GF\": 73, \"PF\": 74, \"GA\": 75, \"GM\": 76, \"GE\": 77, \"DE\": 78, \"GH\": 79, \"GR\": 81, \"GD\": 83, \"GP\": 84, \"GT\": 86, \"GN\": 87, \"GY\": 88, \"HT\": 89, \"HN\": 90, \"HK\": 91, \"HU\": 92, \"IS\": 93, \"ID\": 94, \"IQ\": 95, \"IE\": 96, \"IT\": 97, \"JM\": 98, \"JO\": 100, \"KZ\": 101, \"KE\": 102, \"KI\": 103, \"KW\": 104, \"KG\": 105, \"LA\": 106, \"LV\": 107, \"LB\": 108, \"LS\": 109, \"LR\": 110, \"LY\": 111, \"LT\": 113, \"LU\": 114, \"MO\": 115, \"MK\": 116, \"MG\": 117, \"MW\": 118, \"MY\": 119, \"MV\": 120, \"ML\": 121, \"MT\": 122, \"MQ\": 124, \"MR\": 125, \"MU\": 126, \"MX\": 128, \"FM\": 129, \"MD\": 130, \"MC\": 131, \"MN\": 132, \"MA\": 134, \"MZ\": 135, \"MM\": 136, \"NA\": 137, \"NP\": 139, \"NL\": 140, \"AN\": 141, \"NC\": 142, \"NZ\": 143, \"NI\": 144, \"NE\": 145, \"NG\": 146, \"NO\": 149, \"OM\": 150, \"PK\": 151, \"PW\": 152, \"PA\": 153, \"PG\": 154, \"PY\": 155, \"PE\": 156, \"PH\": 157, \"PL\": 159, \"PT\": 160, \"QA\": 162, \"RE\": 163, \"RO\": 164, \"RW\": 166, \"KN\": 167, \"LC\": 168, \"SA\": 171, \"SN\": 172, \"SC\": 173, \"SG\": 175, \"SK\": 176, \"SI\": 177, \"SO\": 179, \"ZA\": 180, \"KR\": 181, \"ES\": 182, \"LK\": 183, \"SH\": 184, \"SR\": 186, \"SZ\": 187, \"SE\": 188, \"CH\": 189, \"TW\": 191, \"TJ\": 192, \"TZ\": 193, \"TH\": 194, \"TG\": 195, \"TT\": 198, \"TN\": 199, \"TR\": 200, \"TM\": 201, \"UG\": 203, \"UA\": 204, \"AE\": 205, \"GB\": 206, \"UY\": 207, \"UZ\": 208, \"VE\": 211, \"VN\": 212, \"VG\": 213, \"YE\": 216, \"ZM\": 218, \"ZW\": 219, \"RS\": 220, \"ME\": 221, \"IN\": 225, \"TC\": 234, \"CD\": 235, \"GG\": 236, \"IM\": 237, \"JE\": 239, \"CW\": 246, }","title":"get_leader_board"},{"location":"es/binary%20option/binary%20option/","text":"Para opciones binarias \u00b6 comprar \u00b6 comprar una opci\u00f3n binaria buy() \u00b6 Ejemplo from iqoptionapi.stable_api import IQ_Option import logging import time logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"pass\" ) goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ())) Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 check , id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) if check : print ( \"!buy!\" ) else : print ( \"buy fail\" ) Iq . buy ( Money , ACTIVES , ACTION , expirations ) #Money:Cantidad de dinero type(int) #ACTIVES:Ejemplo de entrada \"EURUSD\" OR \"EURGBP\".... puedes ver todos loa ACTIVE con -> get_all_ACTIVES_OPCODE #ACTION:\"call\"/\"put\" type(str) call -> sube, put -> baja #expirations:Introduce minutos, cuidado con los timpos muy largos ya que fallar\u00e1 al comprar (Tiempo de cierre de merrcado) Gracias a Darth-Carrotpie's code (int)https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/6 #return:if sucess return (True,id_number) esle return(Fale,None) buy_multi() \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption Money = [] ACTIVES = [] ACTION = [] expirations_mode = [] Money . append ( 1 ) ACTIVES . append ( \"EURUSD\" ) ACTION . append ( \"call\" ) expirations_mode . append ( 1 ) Money . append ( 1 ) ACTIVES . append ( \"EURAUD\" ) ACTION . append ( \"call\" ) expirations_mode . append ( 1 ) print ( \"buy multi\" ) id_list = Iq . buy_multi ( Money , ACTIVES , ACTION , expirations_mode ) print ( \"check win only one id (id_list[0])\" ) print ( Iq . check_win_v2 ( id_list [ 0 ], 2 )) buy_by_raw_expirations() \u00b6 buy the binary optoin by expired price = 2 active = \"EURUSD\" direction = \"call\" option = \"turbo\" #binary expired = 1293923 # Este tiempo de expiraci\u00f3n necesitas contarlo o obtenerlo por tu mismo Iq . buy_by_raw_expirations ( price , active , direction , option , expired ) get_remaning() \u00b6 purchase time=remaning time - 30 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 while True : remaning_time = Iq . get_remaning ( expirations_mode ) purchase_time = remaning_time - 30 if purchase_time < 4 : #comprar las opciones binarias con un tiempo de compra menor a 4 min Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) break sell_option() \u00b6 Iq . sell_option ( sell_all ) #Introduce int o una lista de id de \u00f3rdenes Ejemplo from iqoptionapi.stable_api import IQ_Option import time print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) id2 = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) time . sleep ( 5 ) sell_all = [] sell_all . append ( id ) sell_all . append ( id2 ) print ( Iq . sell_option ( sell_all )) check win \u00b6 Entrar\u00e1 en bucle hasta que la respuesta sea ganadora (win) o sin beneficios (loose) check_win() \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"Empezando a comprobar la operaci\u00f3n...\" ) print ( Iq . check_win ( id )) Iq . check_win ( 23243221 ) #\"\"Necesitas obtener el id_number de la funci\u00f3n buy()\"\" #Iq.check_win(id_number) #Esta funci\u00f3n entrar\u00e1 en un bucle hasta que el resultado sea: win/equal/loose check_win_v2() \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"Empezando a comprobar la operaci\u00f3n...\" ) polling_time = 3 print ( Iq . check_win_v2 ( id , polling_time )) check_win_v3() \u00b6 Mejor camino para comprobar el resultado de la operaci\u00f3n from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"Empezando a comprobar la operaci\u00f3n...\" ) print ( Iq . check_win_v3 ( id )) get_binary_option_detail() \u00b6 sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_binary_option_detail () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ]) get_all_init() \u00b6 get_binary_option_detail es la base en eta api Tu obtendr\u00e1s los detalle sobre la opci\u00f3n binaria Iq.get_all_init() get_all_profit() \u00b6 sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_all_profit () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ]) Si tu quieres saber el profit en tiempo real get real time profit get_betinfo() \u00b6 Si la opci\u00f3n no cierra todav\u00eda o el id es incorrecto, devolver\u00e1 False if order not close yet or wrong id it will return False isSuccessful , dict = Iq . get_betinfo ( 4452272449 ) #Iq.get_betinfo #ENTRADA: order id #SALIDA:isSuccessful,dict get_optioninfo \u00b6 get_optioninfo() \u00b6 Introduce cu\u00e1ntos datos quieres obtener del historial de Trading (solo para opciones binarias) print ( Iq . get_optioninfo ( 10 )) get_optioninfo_v2() \u00b6 Introduce cu\u00e1ntos datos quieres obtener del historial de Trading (solo para opciones binarias) print ( Iq . get_optioninfo_v2 ( 10 )) get_option_open_by_other_pc() \u00b6 Obtener si tu cuenta tiene otra sesi\u00f3n abierta (puede ser en otro pc) y est\u00e1 abriendo opciones Tu puedes obtener la opci\u00f3n con esta funci\u00f3n import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption while True : #Por favor accede a la web de iqoption y abre alguna opci\u00f3n binaria if Iq . get_option_open_by_other_pc () != {}: break time . sleep ( 1 ) print ( \"Obtener la opci\u00f3n abierta de otra sesi\u00f3n y de la misma cuenta\" ) print ( Iq . get_option_open_by_other_pc ()) id = list ( Iq . get_option_open_by_other_pc () . keys ())[ 0 ] Iq . del_option_open_by_other_pc ( id ) print ( \"Depu\u00e9s de la id\" ) print ( Iq . get_option_open_by_other_pc ()) Obtener indicador \u00b6 Ejemplo\u00a1 \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" Iq . start_mood_stream ( goal ) print ( Iq . get_traders_mood ( goal )) Iq . stop_mood_stream ( goal ) start_mood_stream() \u00b6 Iq . start_mood_stream ( goal ) get_traders_mood() \u00b6 call get_traders_mood() after start_mood_stream Iq . get_traders_mood ( goal ) get_all_traders_mood() \u00b6 Obtendr\u00e1 todo el indicador de operaciones en que hayas activado el stream Iq . get_all_traders_mood () #output:(dict) all mood you start stop_mood_stream() \u00b6 Si no est\u00e1 usando el indicador, porfavor p\u00e1ralo para una mejor conexi\u00f3n. Iq . stop_mood_stream ( goal )","title":"Opciones Binarias"},{"location":"es/binary%20option/binary%20option/#para-opciones-binarias","text":"","title":"Para opciones binarias"},{"location":"es/binary%20option/binary%20option/#comprar","text":"comprar una opci\u00f3n binaria","title":"comprar"},{"location":"es/binary%20option/binary%20option/#buy","text":"Ejemplo from iqoptionapi.stable_api import IQ_Option import logging import time logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"pass\" ) goal = \"EURUSD\" print ( \"get candles\" ) print ( Iq . get_candles ( goal , 60 , 111 , time . time ())) Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 check , id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) if check : print ( \"!buy!\" ) else : print ( \"buy fail\" ) Iq . buy ( Money , ACTIVES , ACTION , expirations ) #Money:Cantidad de dinero type(int) #ACTIVES:Ejemplo de entrada \"EURUSD\" OR \"EURGBP\".... puedes ver todos loa ACTIVE con -> get_all_ACTIVES_OPCODE #ACTION:\"call\"/\"put\" type(str) call -> sube, put -> baja #expirations:Introduce minutos, cuidado con los timpos muy largos ya que fallar\u00e1 al comprar (Tiempo de cierre de merrcado) Gracias a Darth-Carrotpie's code (int)https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/6 #return:if sucess return (True,id_number) esle return(Fale,None)","title":"buy()"},{"location":"es/binary%20option/binary%20option/#buy_multi","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption Money = [] ACTIVES = [] ACTION = [] expirations_mode = [] Money . append ( 1 ) ACTIVES . append ( \"EURUSD\" ) ACTION . append ( \"call\" ) expirations_mode . append ( 1 ) Money . append ( 1 ) ACTIVES . append ( \"EURAUD\" ) ACTION . append ( \"call\" ) expirations_mode . append ( 1 ) print ( \"buy multi\" ) id_list = Iq . buy_multi ( Money , ACTIVES , ACTION , expirations_mode ) print ( \"check win only one id (id_list[0])\" ) print ( Iq . check_win_v2 ( id_list [ 0 ], 2 ))","title":"buy_multi()"},{"location":"es/binary%20option/binary%20option/#buy_by_raw_expirations","text":"buy the binary optoin by expired price = 2 active = \"EURUSD\" direction = \"call\" option = \"turbo\" #binary expired = 1293923 # Este tiempo de expiraci\u00f3n necesitas contarlo o obtenerlo por tu mismo Iq . buy_by_raw_expirations ( price , active , direction , option , expired )","title":"buy_by_raw_expirations()"},{"location":"es/binary%20option/binary%20option/#get_remaning","text":"purchase time=remaning time - 30 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 while True : remaning_time = Iq . get_remaning ( expirations_mode ) purchase_time = remaning_time - 30 if purchase_time < 4 : #comprar las opciones binarias con un tiempo de compra menor a 4 min Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) break","title":"get_remaning()"},{"location":"es/binary%20option/binary%20option/#sell_option","text":"Iq . sell_option ( sell_all ) #Introduce int o una lista de id de \u00f3rdenes Ejemplo from iqoptionapi.stable_api import IQ_Option import time print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption Money = 1 ACTIVES = \"EURUSD\" ACTION = \"call\" #or \"put\" expirations_mode = 1 id = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) id2 = Iq . buy ( Money , ACTIVES , ACTION , expirations_mode ) time . sleep ( 5 ) sell_all = [] sell_all . append ( id ) sell_all . append ( id2 ) print ( Iq . sell_option ( sell_all ))","title":"sell_option()"},{"location":"es/binary%20option/binary%20option/#check-win","text":"Entrar\u00e1 en bucle hasta que la respuesta sea ganadora (win) o sin beneficios (loose)","title":"check win"},{"location":"es/binary%20option/binary%20option/#check_win","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"Empezando a comprobar la operaci\u00f3n...\" ) print ( Iq . check_win ( id )) Iq . check_win ( 23243221 ) #\"\"Necesitas obtener el id_number de la funci\u00f3n buy()\"\" #Iq.check_win(id_number) #Esta funci\u00f3n entrar\u00e1 en un bucle hasta que el resultado sea: win/equal/loose","title":"check_win()"},{"location":"es/binary%20option/binary%20option/#check_win_v2","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"Empezando a comprobar la operaci\u00f3n...\" ) polling_time = 3 print ( Iq . check_win_v2 ( id , polling_time ))","title":"check_win_v2()"},{"location":"es/binary%20option/binary%20option/#check_win_v3","text":"Mejor camino para comprobar el resultado de la operaci\u00f3n from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption check , id = Iq . buy ( 1 , \"EURUSD\" , \"call\" , 1 ) print ( \"Empezando a comprobar la operaci\u00f3n...\" ) print ( Iq . check_win_v3 ( id ))","title":"check_win_v3()"},{"location":"es/binary%20option/binary%20option/#get_binary_option_detail","text":"sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_binary_option_detail () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ])","title":"get_binary_option_detail()"},{"location":"es/binary%20option/binary%20option/#get_all_init","text":"get_binary_option_detail es la base en eta api Tu obtendr\u00e1s los detalle sobre la opci\u00f3n binaria Iq.get_all_init()","title":"get_all_init()"},{"location":"es/binary%20option/binary%20option/#get_all_profit","text":"sample from iqoptionapi.stable_api import IQ_Option print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption d = Iq . get_all_profit () print ( d [ \"CADCHF\" ][ \"turbo\" ]) print ( d [ \"CADCHF\" ][ \"binary\" ]) Si tu quieres saber el profit en tiempo real get real time profit","title":"get_all_profit()"},{"location":"es/binary%20option/binary%20option/#get_betinfo","text":"Si la opci\u00f3n no cierra todav\u00eda o el id es incorrecto, devolver\u00e1 False if order not close yet or wrong id it will return False isSuccessful , dict = Iq . get_betinfo ( 4452272449 ) #Iq.get_betinfo #ENTRADA: order id #SALIDA:isSuccessful,dict","title":"get_betinfo()"},{"location":"es/binary%20option/binary%20option/#get_optioninfo","text":"","title":"get_optioninfo"},{"location":"es/binary%20option/binary%20option/#get_optioninfo_1","text":"Introduce cu\u00e1ntos datos quieres obtener del historial de Trading (solo para opciones binarias) print ( Iq . get_optioninfo ( 10 ))","title":"get_optioninfo()"},{"location":"es/binary%20option/binary%20option/#get_optioninfo_v2","text":"Introduce cu\u00e1ntos datos quieres obtener del historial de Trading (solo para opciones binarias) print ( Iq . get_optioninfo_v2 ( 10 ))","title":"get_optioninfo_v2()"},{"location":"es/binary%20option/binary%20option/#get_option_open_by_other_pc","text":"Obtener si tu cuenta tiene otra sesi\u00f3n abierta (puede ser en otro pc) y est\u00e1 abriendo opciones Tu puedes obtener la opci\u00f3n con esta funci\u00f3n import time from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption while True : #Por favor accede a la web de iqoption y abre alguna opci\u00f3n binaria if Iq . get_option_open_by_other_pc () != {}: break time . sleep ( 1 ) print ( \"Obtener la opci\u00f3n abierta de otra sesi\u00f3n y de la misma cuenta\" ) print ( Iq . get_option_open_by_other_pc ()) id = list ( Iq . get_option_open_by_other_pc () . keys ())[ 0 ] Iq . del_option_open_by_other_pc ( id ) print ( \"Depu\u00e9s de la id\" ) print ( Iq . get_option_open_by_other_pc ())","title":"get_option_open_by_other_pc()"},{"location":"es/binary%20option/binary%20option/#obtener-indicador","text":"","title":"Obtener indicador"},{"location":"es/binary%20option/binary%20option/#ejemplo","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" Iq . start_mood_stream ( goal ) print ( Iq . get_traders_mood ( goal )) Iq . stop_mood_stream ( goal )","title":"Ejemplo\u00a1"},{"location":"es/binary%20option/binary%20option/#start_mood_stream","text":"Iq . start_mood_stream ( goal )","title":"start_mood_stream()"},{"location":"es/binary%20option/binary%20option/#get_traders_mood","text":"call get_traders_mood() after start_mood_stream Iq . get_traders_mood ( goal )","title":"get_traders_mood()"},{"location":"es/binary%20option/binary%20option/#get_all_traders_mood","text":"Obtendr\u00e1 todo el indicador de operaciones en que hayas activado el stream Iq . get_all_traders_mood () #output:(dict) all mood you start","title":"get_all_traders_mood()"},{"location":"es/binary%20option/binary%20option/#stop_mood_stream","text":"Si no est\u00e1 usando el indicador, porfavor p\u00e1ralo para una mejor conexi\u00f3n. Iq . stop_mood_stream ( goal )","title":"stop_mood_stream()"},{"location":"es/candle/candle/","text":"Velas \u00b6 Obtener velas \u00b6 Solo obtiene lass velas cerrada no en tiempo real Iq.get_candles(ACTIVES,interval,count,endtime) #ACTIVES: Ejemplo de entrada \"EURUSD\" OR \"EURGBP\"..\u00f1 #interval: Duraci\u00f3n de las velas en Segundoss #count: Cuantas velas quieres obtener del pasado #endtime: Obtener velas del pasado hasta una fecha concreta Ejemplo \u00b6 from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption end_from_time = time . time () ANS = [] for i in range ( 70 ): data = Iq . get_candles ( \"EURUSD\" , 60 , 1000 , end_from_time ) ANS = data + ANS end_from_time = int ( data [ 0 ][ \"from\" ]) - 1 print ( ANS ) Obtener las nuevas velas en tiempo real \u00b6 Ejemplo de indicador \u00b6 from talib.abstract import * from iqoptionapi.stable_api import IQ_Option import time import numpy as np print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = 10 #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] timeperiod = 10 maxdict = 20 print ( \"Empezar el stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) print ( \"Empezar ejemplo de EMA\" ) while True : candles = Iq . get_realtime_candles ( goal , size ) inputs = { 'open' : np . array ([]), 'high' : np . array ([]), 'low' : np . array ([]), 'close' : np . array ([]), 'volume' : np . array ([]) } for timestamp in candles : inputs [ \"open\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"open\" ] ) inputs [ \"high\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"max\" ] ) inputs [ \"low\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"min\" ] ) inputs [ \"close\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"close\" ] ) inputs [ \"volume\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"volume\" ] ) print ( \"Mostrar la EMA\" ) print ( EMA ( inputs , timeperiod = timeperiod )) print ( \" \\n \" ) time . sleep ( 1 ) Iq . stop_candles_stream ( goal , size ) Ejemplo \u00b6 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') print ( \"Accediendo...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"Empezar stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) #DO something print ( \"Hacer algo...\" ) time . sleep ( 10 ) print ( \"imprimir velas\" ) cc = Iq . get_realtime_candles ( goal , size ) for k in cc : print ( goal , \"size\" , k , cc [ k ]) print ( \"parar velas\" ) Iq . stop_candles_stream ( goal , size ) Tama\u00f1o \u00b6 start_candles_stream() \u00b6 goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) get_realtime_candles() \u00b6 get_realtime_candles() despuess de llamr start_candles_stream() Iq.get_realtime_candles(goal,size) stop_candles_stream() \u00b6 Si no est\u00e1s usando get_realtime_candles() porfavor cierra el stream Iq . stop_candles_stream ( goal , size )","title":"Velas"},{"location":"es/candle/candle/#velas","text":"","title":"Velas"},{"location":"es/candle/candle/#obtener-velas","text":"Solo obtiene lass velas cerrada no en tiempo real Iq.get_candles(ACTIVES,interval,count,endtime) #ACTIVES: Ejemplo de entrada \"EURUSD\" OR \"EURGBP\"..\u00f1 #interval: Duraci\u00f3n de las velas en Segundoss #count: Cuantas velas quieres obtener del pasado #endtime: Obtener velas del pasado hasta una fecha concreta","title":"Obtener velas"},{"location":"es/candle/candle/#ejemplo","text":"from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption end_from_time = time . time () ANS = [] for i in range ( 70 ): data = Iq . get_candles ( \"EURUSD\" , 60 , 1000 , end_from_time ) ANS = data + ANS end_from_time = int ( data [ 0 ][ \"from\" ]) - 1 print ( ANS )","title":"Ejemplo"},{"location":"es/candle/candle/#obtener-las-nuevas-velas-en-tiempo-real","text":"","title":"Obtener las nuevas velas en tiempo real"},{"location":"es/candle/candle/#ejemplo-de-indicador","text":"from talib.abstract import * from iqoptionapi.stable_api import IQ_Option import time import numpy as np print ( \"login...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = 10 #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] timeperiod = 10 maxdict = 20 print ( \"Empezar el stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) print ( \"Empezar ejemplo de EMA\" ) while True : candles = Iq . get_realtime_candles ( goal , size ) inputs = { 'open' : np . array ([]), 'high' : np . array ([]), 'low' : np . array ([]), 'close' : np . array ([]), 'volume' : np . array ([]) } for timestamp in candles : inputs [ \"open\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"open\" ] ) inputs [ \"high\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"max\" ] ) inputs [ \"low\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"min\" ] ) inputs [ \"close\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"close\" ] ) inputs [ \"volume\" ] = np . append ( inputs [ \"open\" ], candles [ timestamp ][ \"volume\" ] ) print ( \"Mostrar la EMA\" ) print ( EMA ( inputs , timeperiod = timeperiod )) print ( \" \\n \" ) time . sleep ( 1 ) Iq . stop_candles_stream ( goal , size )","title":"Ejemplo de indicador"},{"location":"es/candle/candle/#ejemplo_1","text":"from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') print ( \"Accediendo...\" ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"Empezar stream...\" ) Iq . start_candles_stream ( goal , size , maxdict ) #DO something print ( \"Hacer algo...\" ) time . sleep ( 10 ) print ( \"imprimir velas\" ) cc = Iq . get_realtime_candles ( goal , size ) for k in cc : print ( goal , \"size\" , k , cc [ k ]) print ( \"parar velas\" ) Iq . stop_candles_stream ( goal , size )","title":"Ejemplo"},{"location":"es/candle/candle/#tamano","text":"","title":"Tama\u00f1o"},{"location":"es/candle/candle/#start_candles_stream","text":"goal = \"EURUSD\" size = \"all\" #size=[1,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,28800,43200,86400,604800,2592000,\"all\"] maxdict = 10 print ( \"start stream...\" ) Iq . start_candles_stream ( goal , size , maxdict )","title":"start_candles_stream()"},{"location":"es/candle/candle/#get_realtime_candles","text":"get_realtime_candles() despuess de llamr start_candles_stream() Iq.get_realtime_candles(goal,size)","title":"get_realtime_candles()"},{"location":"es/candle/candle/#stop_candles_stream","text":"Si no est\u00e1s usando get_realtime_candles() porfavor cierra el stream Iq . stop_candles_stream ( goal , size )","title":"stop_candles_stream()"},{"location":"es/digital/digital/","text":"Digital \u00b6 Cerca del modo strike \u00b6 Ejemplo \u00b6 from iqoptionapi.stable_api import IQ_Option import time import random Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 amount = 1 Iq . subscribe_strike_list ( ACTIVES , duration ) #get strike_list data = Iq . get_realtime_strike_list ( ACTIVES , duration ) print ( \"get strike data\" ) print ( data ) \"\"\"data {'1.127100': { 'call': { 'profit': None, 'id': 'doEURUSD201811120649PT1MC11271' }, 'put': { 'profit': 566.6666666666666, 'id': 'doEURUSD201811120649PT1MP11271' } }............ } \"\"\" #Obtener la lista de precios price_list = list ( data . keys ()) #Elegir una estrat\u00e9gia aleatoria choose_price = price_list [ random . randint ( 0 , len ( price_list ) - 1 )] #Obtener instrument_id instrument_id = data [ choose_price ][ \"call\" ][ \"id\" ] #Obtener profit profit = data [ choose_price ][ \"call\" ][ \"profit\" ] print ( \"Elegir que quiere commprar\" ) print ( \"precio:\" , choose_price , \"side:call\" , \"instrument_id:\" , instrument_id , \"profit:\" , profit ) #Escojer instrument_id para abrir operaci\u00f3n buy_check , id = Iq . buy_digital ( amount , instrument_id ) polling_time = 5 if buy_check : print ( \"Esperar para comprobar win\" ) #comprobar win while True : check_close , win_money = Iq . check_win_digital_v2 ( id , polling_time ) if check_close : if float ( win_money ) > 0 : win_money = ( \" %.2f \" % ( win_money )) print ( \"Tu has ganado\" , win_money , \"dinero\" ) else : print ( \"Sin beneficioss\" ) break Iq . unsubscribe_strike_list ( ACTIVES , duration ) else : print ( \"Fallo al comprar, porfavor prueba otra vez\" ) Obtener toda la lissta de datos de todos los strike \u00b6 Ejemplo from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conecta a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_realtime_strike_list ( ACTIVES , duration ) for price in data : print ( \"precio\" , price , data [ price ]) time . sleep ( 5 ) Iq . unsubscribe_strike_list ( ACTIVES , duration ) subscribe_strike_list() \u00b6 Iq . subscribe_strike_list ( ACTIVES , duration ) get_realtime_strike_list \u00b6 Tu necesitas llamar a subscribe_strike_list() antes de get_realtime_strike_list() Iq . get_realtime_strike_list ( ACTIVES , duration ) unsubscribe_strike_list() \u00b6 Iq . unsubscribe_strike_list ( ACTIVES , duration ) buy_digital() \u00b6 buy_check , id = Iq . buy_digital ( amount , instrument_id ) #obtener el instrument_id de Iq.get_realtime_strike_list Modo actual del precio \u00b6 buy_digital_spot \u00b6 Comprar el d\u00edgito en el precio actual Devuelve check y id from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 amount = 1 action = \"call\" #put print ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration )) get_digital_spot_profit_after_sale() \u00b6 Obtener Profit despu\u00e9s de la Venta(P/L) Ejemplo from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"passord\" ) ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 100 action = \"put\" #put Iq . subscribe_strike_list ( ACTIVES , duration ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : PL = Iq . get_digital_spot_profit_after_sale ( id ) if PL != None : print ( PL ) get_digital_current_profit() \u00b6 from iqoptionapi.stable_api import IQ_Option import time import logging #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_digital_current_profit ( ACTIVES , duration ) print ( data ) # La primera impresi\u00f3n puede ser falsa, s\u00f3lo espera un segundo puedes obtener el beneficio time . sleep ( 1 ) Iq . unsubscribe_strike_list ( ACTIVES , duration ) check win for digital \u00b6 check_win_digital() \u00b6 Esta api esta implementada por get_digital_position() Esta funci\u00f3n esta encuestando, necesitas escojet el tiempo de encuesta Iq . check_win_digital ( id , polling_time ) #obtener el id de Iq.buy_digital check_win_digital_v2() \u00b6 Esta api es as\u00edncrona, obtiene el id de los datos. Solo puede obtener el id de los datos antess de que puedass comprar la opci\u00f3n. Si reinicias el programa, no se puede obtener otra vez la id de los datos de manera as\u00edncrona otra vez. De esta forma no se puede trabajar con check_win_digital_v2, asi tu necesitas usar check_win_digital. Iq . check_win_digital_v2 ( id ) #obtener el id deIq.buy_digital #return:check_close,win_money #return sample #if you loose:Ture,o #if you win:True,1232.3 #if trade not clode yet:False,None Ejemplo de c\u00f3digo from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 amount = 1 action = \"call\" #put _ , id = ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration )) print ( id ) if id != \"error\" : while True : check , win = Iq . check_win_digital_v2 ( id ) if check == True : break if win < 0 : print ( \"Has perdido \" + str ( win ) + \"$\" ) else : print ( \"Has ganado \" + str ( win ) + \"$\" ) else : print ( \"Porfavor prueba otra vez\" ) close_digital_option() \u00b6 Iq . close_digital_option ( id ) Obtener datos de opciones digitaless \u00b6 Ejemplo 1 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD-OTC\" duration = 1 #minuto 1 or 5 amount = 1 action = \"call\" #put from datetime import datetime _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : check , _ = Iq . check_win_digital ( id ) if check : break print ( Iq . get_digital_position ( id )) print ( Iq . check_win_digital ( id )) Ejemplo 2 print ( Iq . get_positions ( \"digital-option\" )) print ( Iq . get_digital_position ( 2323433 )) #Comprobar por id print ( Iq . get_position_history ( \"digital-option\" ))","title":"Digital"},{"location":"es/digital/digital/#digital","text":"","title":"Digital"},{"location":"es/digital/digital/#cerca-del-modo-strike","text":"","title":"Cerca del modo strike"},{"location":"es/digital/digital/#ejemplo","text":"from iqoptionapi.stable_api import IQ_Option import time import random Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 amount = 1 Iq . subscribe_strike_list ( ACTIVES , duration ) #get strike_list data = Iq . get_realtime_strike_list ( ACTIVES , duration ) print ( \"get strike data\" ) print ( data ) \"\"\"data {'1.127100': { 'call': { 'profit': None, 'id': 'doEURUSD201811120649PT1MC11271' }, 'put': { 'profit': 566.6666666666666, 'id': 'doEURUSD201811120649PT1MP11271' } }............ } \"\"\" #Obtener la lista de precios price_list = list ( data . keys ()) #Elegir una estrat\u00e9gia aleatoria choose_price = price_list [ random . randint ( 0 , len ( price_list ) - 1 )] #Obtener instrument_id instrument_id = data [ choose_price ][ \"call\" ][ \"id\" ] #Obtener profit profit = data [ choose_price ][ \"call\" ][ \"profit\" ] print ( \"Elegir que quiere commprar\" ) print ( \"precio:\" , choose_price , \"side:call\" , \"instrument_id:\" , instrument_id , \"profit:\" , profit ) #Escojer instrument_id para abrir operaci\u00f3n buy_check , id = Iq . buy_digital ( amount , instrument_id ) polling_time = 5 if buy_check : print ( \"Esperar para comprobar win\" ) #comprobar win while True : check_close , win_money = Iq . check_win_digital_v2 ( id , polling_time ) if check_close : if float ( win_money ) > 0 : win_money = ( \" %.2f \" % ( win_money )) print ( \"Tu has ganado\" , win_money , \"dinero\" ) else : print ( \"Sin beneficioss\" ) break Iq . unsubscribe_strike_list ( ACTIVES , duration ) else : print ( \"Fallo al comprar, porfavor prueba otra vez\" )","title":"Ejemplo"},{"location":"es/digital/digital/#obtener-toda-la-lissta-de-datos-de-todos-los-strike","text":"Ejemplo from iqoptionapi.stable_api import IQ_Option import time Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conecta a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_realtime_strike_list ( ACTIVES , duration ) for price in data : print ( \"precio\" , price , data [ price ]) time . sleep ( 5 ) Iq . unsubscribe_strike_list ( ACTIVES , duration )","title":"Obtener toda la lissta de datos de todos los strike"},{"location":"es/digital/digital/#subscribe_strike_list","text":"Iq . subscribe_strike_list ( ACTIVES , duration )","title":"subscribe_strike_list()"},{"location":"es/digital/digital/#get_realtime_strike_list","text":"Tu necesitas llamar a subscribe_strike_list() antes de get_realtime_strike_list() Iq . get_realtime_strike_list ( ACTIVES , duration )","title":"get_realtime_strike_list"},{"location":"es/digital/digital/#unsubscribe_strike_list","text":"Iq . unsubscribe_strike_list ( ACTIVES , duration )","title":"unsubscribe_strike_list()"},{"location":"es/digital/digital/#buy_digital","text":"buy_check , id = Iq . buy_digital ( amount , instrument_id ) #obtener el instrument_id de Iq.get_realtime_strike_list","title":"buy_digital()"},{"location":"es/digital/digital/#modo-actual-del-precio","text":"","title":"Modo actual del precio"},{"location":"es/digital/digital/#buy_digital_spot","text":"Comprar el d\u00edgito en el precio actual Devuelve check y id from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 amount = 1 action = \"call\" #put print ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration ))","title":"buy_digital_spot"},{"location":"es/digital/digital/#get_digital_spot_profit_after_sale","text":"Obtener Profit despu\u00e9s de la Venta(P/L) Ejemplo from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"passord\" ) ACTIVES = \"EURUSD\" duration = 1 #minute 1 or 5 amount = 100 action = \"put\" #put Iq . subscribe_strike_list ( ACTIVES , duration ) _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : PL = Iq . get_digital_spot_profit_after_sale ( id ) if PL != None : print ( PL )","title":"get_digital_spot_profit_after_sale()"},{"location":"es/digital/digital/#get_digital_current_profit","text":"from iqoptionapi.stable_api import IQ_Option import time import logging #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 Iq . subscribe_strike_list ( ACTIVES , duration ) while True : data = Iq . get_digital_current_profit ( ACTIVES , duration ) print ( data ) # La primera impresi\u00f3n puede ser falsa, s\u00f3lo espera un segundo puedes obtener el beneficio time . sleep ( 1 ) Iq . unsubscribe_strike_list ( ACTIVES , duration )","title":"get_digital_current_profit()"},{"location":"es/digital/digital/#check-win-for-digital","text":"","title":"check win for digital"},{"location":"es/digital/digital/#check_win_digital","text":"Esta api esta implementada por get_digital_position() Esta funci\u00f3n esta encuestando, necesitas escojet el tiempo de encuesta Iq . check_win_digital ( id , polling_time ) #obtener el id de Iq.buy_digital","title":"check_win_digital()"},{"location":"es/digital/digital/#check_win_digital_v2","text":"Esta api es as\u00edncrona, obtiene el id de los datos. Solo puede obtener el id de los datos antess de que puedass comprar la opci\u00f3n. Si reinicias el programa, no se puede obtener otra vez la id de los datos de manera as\u00edncrona otra vez. De esta forma no se puede trabajar con check_win_digital_v2, asi tu necesitas usar check_win_digital. Iq . check_win_digital_v2 ( id ) #obtener el id deIq.buy_digital #return:check_close,win_money #return sample #if you loose:Ture,o #if you win:True,1232.3 #if trade not clode yet:False,None Ejemplo de c\u00f3digo from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #connect to iqoption ACTIVES = \"EURUSD\" duration = 1 #minuto 1 or 5 amount = 1 action = \"call\" #put _ , id = ( Iq . buy_digital_spot ( ACTIVES , amount , action , duration )) print ( id ) if id != \"error\" : while True : check , win = Iq . check_win_digital_v2 ( id ) if check == True : break if win < 0 : print ( \"Has perdido \" + str ( win ) + \"$\" ) else : print ( \"Has ganado \" + str ( win ) + \"$\" ) else : print ( \"Porfavor prueba otra vez\" )","title":"check_win_digital_v2()"},{"location":"es/digital/digital/#close_digital_option","text":"Iq . close_digital_option ( id )","title":"close_digital_option()"},{"location":"es/digital/digital/#obtener-datos-de-opciones-digitaless","text":"Ejemplo 1 from iqoptionapi.stable_api import IQ_Option import logging import time #logging.basicConfig(level=logging.DEBUG,format='%(asctime)s %(message)s') Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption ACTIVES = \"EURUSD-OTC\" duration = 1 #minuto 1 or 5 amount = 1 action = \"call\" #put from datetime import datetime _ , id = Iq . buy_digital_spot ( ACTIVES , amount , action , duration ) while True : check , _ = Iq . check_win_digital ( id ) if check : break print ( Iq . get_digital_position ( id )) print ( Iq . check_win_digital ( id )) Ejemplo 2 print ( Iq . get_positions ( \"digital-option\" )) print ( Iq . get_digital_position ( 2323433 )) #Comprobar por id print ( Iq . get_position_history ( \"digital-option\" ))","title":"Obtener datos de opciones digitaless"},{"location":"es/fef/fef/","text":"Forex&Stock&Commodities&Crypto&ETFs \u00b6 instrument_type y instrument_id \u00b6 Tu puedes buscar instrument_type and instrument_id de este archivo buscar instrument_type and instrument_id Ejemplo \u00b6 from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" #Introducir:\"buy\"/\"sell\" amount = 1.23 #Introducir la cantidad de dinero por operaci\u00f3n #\"leverage\"=\"Multiplier\" leverage = 3 #Puedes obtener m\u00e1s sinformaci\u00f3n de get_available_leverages() type = \"market\" #Introducir:\"market\"/\"limit\"/\"stop\" #Para type=\"limit\"/\"stop\" # olo funciona con type=\"limit\" limit_price = None #input:None/value(float/int) #Solo funciona con type=\"stop\" stop_price = None #input:None/value(float/int) #\"percent\"=Profit Percentage #\"price\"=Asset Price #\"diff\"=Profit in Money stop_lose_kind = \"percent\" #input:None/\"price\"/\"diff\"/\"percent\" stop_lose_value = 95 #input:None/value(float/int) take_profit_kind = None #input:None/\"price\"/\"diff\"/\"percent\" take_profit_value = None #input:None/value(float/int) #\"use_trail_stop\"=\"Trailing Stop\" use_trail_stop = True #True/False #\"auto_margin_call\"=\"Utilizar el dinero te la cuenta para mantener Abierta la Posici\u00f3n\" auto_margin_call = False #True/False #Si tu quieres \"take_profit_kind\"& # \"take_profit_value\"& # \"stop_lose_kind\"& # \"stop_lose_value\" all being \"Not Set\",\"auto_margin_call\" need to set:True use_token_for_commission = False #True/False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) print ( Iq . get_order ( order_id )) print ( Iq . get_positions ( \"crypto\" )) print ( Iq . get_position_history ( \"crypto\" )) print ( Iq . get_available_leverages ( \"crypto\" , \"BTCUSD\" )) print ( Iq . close_position ( order_id )) print ( Iq . get_overnight_fee ( \"crypto\" , \"BTCUSD\" )) buy_order() \u00b6 devuelve (True/False,buy_order_id/False) Si Buy es satisfactoria devuelve (True,buy_order_id) \"percent\"=Profit Percentage \"price\"=Asset Price \"diff\"=Profit en dinero parameter instrument_type instrument_type instrument_id instrument_id side \"buy\" \"sell\" amount value(float/int) leverage value(int) type \"market\" \"limit\" \"stop\" limit_price None value(float/int):Only working by set type=\"limit\" stop_price None value(float/int):Only working by set type=\"stop\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False use_token_for_commission True False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) change_order() \u00b6 ID_Name=\"\"order_id\" ID_Name=\"position_id\" parameter ID_Name \"position_id\" \"order_id\" order_id \"you need to get order_id from buy_order()\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False sample \u00b6 ID_Name = \"order_id\" #\"position_id\"/\"order_id\" stop_lose_kind = None stop_lose_value = None take_profit_kind = \"percent\" take_profit_value = 200 use_trail_stop = False auto_margin_call = True Iq . change_order ( ID_Name = ID_Name , order_id = order_id , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call ) get_order() \u00b6 Obtener informaci\u00f3n sobre buy_order_id devuelve (True/False,get_order,None) Iq . get_order ( buy_order_id ) get_pending() \u00b6 Obtendr\u00e1s los dato Iq . get_pending ( instrument_type ) get_positions() \u00b6 Obtendr\u00e1 los datos devuelve (True/False,get_positions,None) no soporte para \"\"turbo-option\"\" instrument_type=\"crypto\",\"forex\",\"fx-option\",\"multi-option\",\"cfd\",\"digital-option\" Iq . get_positions ( instrument_type ) get_position() \u00b6 Obtendr\u00e1s los datos Obtendr\u00e1ss una possici\u00f3n por buy_order_id devuelve (True/False,position data,None) Iq . get_positions ( buy_order_id ) get_position_history \u00b6 Obtendr\u00e1s los datos get_position_history() \u00b6 devuelve (True/False,position_history,None) Iq.get_position_history(instrument_type) get_position_history_v2 \u00b6 instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" get_position_history_v2(instrument_type,limit,offset,start,end) from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption #instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" instrument_type = \"digital-option\" limit = 2 #Cu\u00e1ntos quieres obtener offset = 0 #offset de tiempo final, si el tiempo final es 0,significa que se obtendr\u00e1n los datos desde ahora start = 0 #Empezar el tiempo en Timestamp end = 0 #Timestamp data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data ) #--------- Esto obtendr\u00e1 los datos empezando por 2019/7/1(end) hasta 2019/1/1(start) y solo obteniendo 2(limit) datoss siendo el offset 0 instrument_type = \"digital-option\" limit = 2 #Cu\u00e1ntos quieres obtener offset = 0 #offset de tiempo final, si el tiempo final es 0, significa que se obtendr\u00e1n los datos desde ahora start = int ( time . mktime ( datetime . datetime . strptime ( \"2019/1/1\" , \"%Y/%m/ %d \" ) . timetuple ())) end = int ( time . mktime ( datetime . datetime . strptime ( \"2019/7/1\" , \"%Y/%m/ %d \" ) . timetuple ())) data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data ) get_available_leverages() \u00b6 Obtener apalancamiento disponible devuelve (True/False,available_leverages,None) Iq . get_available_leverages ( instrument_type , actives ) cancel_order() \u00b6 Cancelar\u00e1s la orden devuelve (True/False) Iq . cancel_order ( buy_order_id ) close_position() \u00b6 Cancelar\u00e1s la poici\u00f3n devuelve (True/False) Iq . close_position ( buy_order_id ) get_overnight_fee() \u00b6 devuelve (True/False,overnight_fee,None) Iq . get_overnight_fee ( instrument_type , active )","title":"Furutos de divisas"},{"location":"es/fef/fef/#forexstockcommoditiescryptoetfs","text":"","title":"Forex&amp;Stock&amp;Commodities&amp;Crypto&amp;ETFs"},{"location":"es/fef/fef/#instrument_type-y-instrument_id","text":"Tu puedes buscar instrument_type and instrument_id de este archivo buscar instrument_type and instrument_id","title":"instrument_type y instrument_id"},{"location":"es/fef/fef/#ejemplo","text":"from iqoptionapi.stable_api import IQ_Option Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption instrument_type = \"crypto\" instrument_id = \"BTCUSD\" side = \"buy\" #Introducir:\"buy\"/\"sell\" amount = 1.23 #Introducir la cantidad de dinero por operaci\u00f3n #\"leverage\"=\"Multiplier\" leverage = 3 #Puedes obtener m\u00e1s sinformaci\u00f3n de get_available_leverages() type = \"market\" #Introducir:\"market\"/\"limit\"/\"stop\" #Para type=\"limit\"/\"stop\" # olo funciona con type=\"limit\" limit_price = None #input:None/value(float/int) #Solo funciona con type=\"stop\" stop_price = None #input:None/value(float/int) #\"percent\"=Profit Percentage #\"price\"=Asset Price #\"diff\"=Profit in Money stop_lose_kind = \"percent\" #input:None/\"price\"/\"diff\"/\"percent\" stop_lose_value = 95 #input:None/value(float/int) take_profit_kind = None #input:None/\"price\"/\"diff\"/\"percent\" take_profit_value = None #input:None/value(float/int) #\"use_trail_stop\"=\"Trailing Stop\" use_trail_stop = True #True/False #\"auto_margin_call\"=\"Utilizar el dinero te la cuenta para mantener Abierta la Posici\u00f3n\" auto_margin_call = False #True/False #Si tu quieres \"take_profit_kind\"& # \"take_profit_value\"& # \"stop_lose_kind\"& # \"stop_lose_value\" all being \"Not Set\",\"auto_margin_call\" need to set:True use_token_for_commission = False #True/False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_value = stop_lose_value , stop_lose_kind = stop_lose_kind , take_profit_value = take_profit_value , take_profit_kind = take_profit_kind , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission ) print ( Iq . get_order ( order_id )) print ( Iq . get_positions ( \"crypto\" )) print ( Iq . get_position_history ( \"crypto\" )) print ( Iq . get_available_leverages ( \"crypto\" , \"BTCUSD\" )) print ( Iq . close_position ( order_id )) print ( Iq . get_overnight_fee ( \"crypto\" , \"BTCUSD\" ))","title":"Ejemplo"},{"location":"es/fef/fef/#buy_order","text":"devuelve (True/False,buy_order_id/False) Si Buy es satisfactoria devuelve (True,buy_order_id) \"percent\"=Profit Percentage \"price\"=Asset Price \"diff\"=Profit en dinero parameter instrument_type instrument_type instrument_id instrument_id side \"buy\" \"sell\" amount value(float/int) leverage value(int) type \"market\" \"limit\" \"stop\" limit_price None value(float/int):Only working by set type=\"limit\" stop_price None value(float/int):Only working by set type=\"stop\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False use_token_for_commission True False check , order_id = Iq . buy_order ( instrument_type = instrument_type , instrument_id = instrument_id , side = side , amount = amount , leverage = leverage , type = type , limit_price = limit_price , stop_price = stop_price , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call , use_token_for_commission = use_token_for_commission )","title":"buy_order()"},{"location":"es/fef/fef/#change_order","text":"ID_Name=\"\"order_id\" ID_Name=\"position_id\" parameter ID_Name \"position_id\" \"order_id\" order_id \"you need to get order_id from buy_order()\" stop_lose_kind None \"price\" \"diff\" \"percent\" stop_lose_value None value(float/int) take_profit_kind None \"price\" \"diff\" \"percent\" take_profit_value None value(float/int) use_trail_stop True False auto_margin_call True False","title":"change_order()"},{"location":"es/fef/fef/#sample","text":"ID_Name = \"order_id\" #\"position_id\"/\"order_id\" stop_lose_kind = None stop_lose_value = None take_profit_kind = \"percent\" take_profit_value = 200 use_trail_stop = False auto_margin_call = True Iq . change_order ( ID_Name = ID_Name , order_id = order_id , stop_lose_kind = stop_lose_kind , stop_lose_value = stop_lose_value , take_profit_kind = take_profit_kind , take_profit_value = take_profit_value , use_trail_stop = use_trail_stop , auto_margin_call = auto_margin_call )","title":"sample"},{"location":"es/fef/fef/#get_order","text":"Obtener informaci\u00f3n sobre buy_order_id devuelve (True/False,get_order,None) Iq . get_order ( buy_order_id )","title":"get_order()"},{"location":"es/fef/fef/#get_pending","text":"Obtendr\u00e1s los dato Iq . get_pending ( instrument_type )","title":"get_pending()"},{"location":"es/fef/fef/#get_positions","text":"Obtendr\u00e1 los datos devuelve (True/False,get_positions,None) no soporte para \"\"turbo-option\"\" instrument_type=\"crypto\",\"forex\",\"fx-option\",\"multi-option\",\"cfd\",\"digital-option\" Iq . get_positions ( instrument_type )","title":"get_positions()"},{"location":"es/fef/fef/#get_position","text":"Obtendr\u00e1s los datos Obtendr\u00e1ss una possici\u00f3n por buy_order_id devuelve (True/False,position data,None) Iq . get_positions ( buy_order_id )","title":"get_position()"},{"location":"es/fef/fef/#get_position_history","text":"Obtendr\u00e1s los datos","title":"get_position_history"},{"location":"es/fef/fef/#get_position_history_1","text":"devuelve (True/False,position_history,None) Iq.get_position_history(instrument_type)","title":"get_position_history()"},{"location":"es/fef/fef/#get_position_history_v2","text":"instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" get_position_history_v2(instrument_type,limit,offset,start,end) from iqoptionapi.stable_api import IQ_Option import logging import random import time import datetime logging . basicConfig ( level = logging . DEBUG , format = ' %(asctime)s %(message)s ' ) Iq = IQ_Option ( \"email\" , \"password\" ) Iq . connect () #conectar a iqoption #instrument_type=\"crypto\",\"forex\",\"fx-option\",\"turbo-option\",\"multi-option\",\"cfd\",\"digital-option\" instrument_type = \"digital-option\" limit = 2 #Cu\u00e1ntos quieres obtener offset = 0 #offset de tiempo final, si el tiempo final es 0,significa que se obtendr\u00e1n los datos desde ahora start = 0 #Empezar el tiempo en Timestamp end = 0 #Timestamp data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data ) #--------- Esto obtendr\u00e1 los datos empezando por 2019/7/1(end) hasta 2019/1/1(start) y solo obteniendo 2(limit) datoss siendo el offset 0 instrument_type = \"digital-option\" limit = 2 #Cu\u00e1ntos quieres obtener offset = 0 #offset de tiempo final, si el tiempo final es 0, significa que se obtendr\u00e1n los datos desde ahora start = int ( time . mktime ( datetime . datetime . strptime ( \"2019/1/1\" , \"%Y/%m/ %d \" ) . timetuple ())) end = int ( time . mktime ( datetime . datetime . strptime ( \"2019/7/1\" , \"%Y/%m/ %d \" ) . timetuple ())) data = Iq . get_position_history_v2 ( instrument_type , limit , offset , start , end ) print ( data )","title":"get_position_history_v2"},{"location":"es/fef/fef/#get_available_leverages","text":"Obtener apalancamiento disponible devuelve (True/False,available_leverages,None) Iq . get_available_leverages ( instrument_type , actives )","title":"get_available_leverages()"},{"location":"es/fef/fef/#cancel_order","text":"Cancelar\u00e1s la orden devuelve (True/False) Iq . cancel_order ( buy_order_id )","title":"cancel_order()"},{"location":"es/fef/fef/#close_position","text":"Cancelar\u00e1s la poici\u00f3n devuelve (True/False) Iq . close_position ( buy_order_id )","title":"close_position()"},{"location":"es/fef/fef/#get_overnight_fee","text":"devuelve (True/False,overnight_fee,None) Iq . get_overnight_fee ( instrument_type , active )","title":"get_overnight_fee()"},{"location":"es/techinical%20analysis/","text":"Tecnical analysis \u00b6 Est\u00e1 disponible en los assets que puedes comprobar en \"asset info\": Si hay una sesi\u00f3n como esta tu puedes obtener los datos NOTA: Si no hay an\u00e1lisis t\u00e9cnico en el asset que tu quieres, no podr\u00e1s uarlo Hay algunos indicadores disponibles Pivotes \u00b6 Osciladores \u00b6 Promedioss m\u00f3viles \u00b6 C\u00f3mo usar: \u00b6 asset = \"GBPUSD\" indicators = Iq . get_technical_indicators ( asset ) print ( indicators ) Si el asset no contiene el an\u00e1lisis t\u00e9cnico, devolver\u00e1: { \"code\": \"no_technical_indicator_available\", \"message\": \"Active is not supported: active id 'ACTIVE_ID_PASSED'\" } Si lo contiene, devolver\u00e1 algo parecido a esto: NOTA: DEBE ANALIZAR EL CONTENIDO QUE SE IMPRIME [ { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"OSCILLATORS\" , \"name\" : \"Relative Strength Index (14)\" , \"value\" : 59.168583 }, { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"PIVOTS\" , \"name\" : \"Classic s3\" , \"value\" : 1.057292 } ..... ]","title":"An\u00e1lisis t\u00e9cnico"},{"location":"es/techinical%20analysis/#tecnical-analysis","text":"Est\u00e1 disponible en los assets que puedes comprobar en \"asset info\": Si hay una sesi\u00f3n como esta tu puedes obtener los datos NOTA: Si no hay an\u00e1lisis t\u00e9cnico en el asset que tu quieres, no podr\u00e1s uarlo Hay algunos indicadores disponibles","title":"Tecnical analysis"},{"location":"es/techinical%20analysis/#pivotes","text":"","title":"Pivotes"},{"location":"es/techinical%20analysis/#osciladores","text":"","title":"Osciladores"},{"location":"es/techinical%20analysis/#promedioss-moviles","text":"","title":"Promedioss m\u00f3viles"},{"location":"es/techinical%20analysis/#como-usar","text":"asset = \"GBPUSD\" indicators = Iq . get_technical_indicators ( asset ) print ( indicators ) Si el asset no contiene el an\u00e1lisis t\u00e9cnico, devolver\u00e1: { \"code\": \"no_technical_indicator_available\", \"message\": \"Active is not supported: active id 'ACTIVE_ID_PASSED'\" } Si lo contiene, devolver\u00e1 algo parecido a esto: NOTA: DEBE ANALIZAR EL CONTENIDO QUE SE IMPRIME [ { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"OSCILLATORS\" , \"name\" : \"Relative Strength Index (14)\" , \"value\" : 59.168583 }, { \"action\" : \"hold\" , \"candle_size\" : 60 , \"group\" : \"PIVOTS\" , \"name\" : \"Classic s3\" , \"value\" : 1.057292 } ..... ]","title":"C\u00f3mo usar:"},{"location":"pt/","text":"IQ Option API \u00b6 Ainda n\u00e3o possui a tradu\u00e7\u00e3o em portugues. Em breve estar\u00e1 disponivel.","title":"Primeiros Passos"},{"location":"pt/#iq-option-api","text":"Ainda n\u00e3o possui a tradu\u00e7\u00e3o em portugues. Em breve estar\u00e1 disponivel.","title":"IQ Option API"},{"location":"pt/changelog/","text":"Version 5.3.0 \u00b6 add technical Indicators from iqoptionapi.stable_api import IQ_Option import logging import time import userdata asset = \"EURUSD\" maxdict = 10 size = 300 logging . disable ( level = ( logging . DEBUG )) user = userdata . mainUser Iq = IQ_Option ( user [ \"username\" ], user [ \"password\" ]) indicators = Iq . get_technical_indicators ( asset ) print ( indicators ) print ( \"passou while bot\" ) Version: 5.1.1 \u00b6 fix change_balance \u00b6 from iqoptionapi.stable_api import IQ_Option email = \"your@mail.ocm\" password = \"your_password\" account_mode = \"real\" # real/practic Iq = IQ_Option ( email , password , account_mode ) balance_id = Iq . change_balance ( \"practic\" ) Add option balance_mode on create IQ_Option objetct. \u00b6 from iqoptionapi.stable_api import IQ_Option email = \"your@mail.ocm\" password = \"your_password\" account_mode = \"real\" # real/practic Iq = IQ_Option ( email , password , account_mode ) last update:2019/11/22 Version:5.1 add get_option_open_by_other_pc api Version:5.0 please donate >< get_digital_spot_profit_after_sale pay me lot of time https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/125 add get_digital_spot_profit_after_sale api Version:4.5 add get_remaning api Version:4.4 fix check_win_digital(check_win_digital(Synchronous message) and check_win_digital_v2(Asynchronous messages) are different implement way) add get_digital_position() Version:4.3 add subscribe_top_assets_updated & popularity https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/131 Version:4.2 add reconnect sample add get_async_order api Version:4.0.1 fix get_positions() https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/132 add get_optioninfo_v2 Version:4.0.0 :exclamation::exclamation::exclamation: update websocket-client==0.56 :exclamation: please uninstall all websocket-client and update up websocket-client==0.56 sudo pip uninstall websocket-client sudo pip install websocket-client==0.56 :exclamation:","title":"Changelog"},{"location":"pt/changelog/#version-530","text":"add technical Indicators from iqoptionapi.stable_api import IQ_Option import logging import time import userdata asset = \"EURUSD\" maxdict = 10 size = 300 logging . disable ( level = ( logging . DEBUG )) user = userdata . mainUser Iq = IQ_Option ( user [ \"username\" ], user [ \"password\" ]) indicators = Iq . get_technical_indicators ( asset ) print ( indicators ) print ( \"passou while bot\" )","title":"Version 5.3.0"},{"location":"pt/changelog/#version-511","text":"","title":"Version: 5.1.1"},{"location":"pt/changelog/#fix-change_balance","text":"from iqoptionapi.stable_api import IQ_Option email = \"your@mail.ocm\" password = \"your_password\" account_mode = \"real\" # real/practic Iq = IQ_Option ( email , password , account_mode ) balance_id = Iq . change_balance ( \"practic\" )","title":"fix change_balance"},{"location":"pt/changelog/#add-option-balance_mode-on-create-iq_option-objetct","text":"from iqoptionapi.stable_api import IQ_Option email = \"your@mail.ocm\" password = \"your_password\" account_mode = \"real\" # real/practic Iq = IQ_Option ( email , password , account_mode ) last update:2019/11/22 Version:5.1 add get_option_open_by_other_pc api Version:5.0 please donate >< get_digital_spot_profit_after_sale pay me lot of time https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/125 add get_digital_spot_profit_after_sale api Version:4.5 add get_remaning api Version:4.4 fix check_win_digital(check_win_digital(Synchronous message) and check_win_digital_v2(Asynchronous messages) are different implement way) add get_digital_position() Version:4.3 add subscribe_top_assets_updated & popularity https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/131 Version:4.2 add reconnect sample add get_async_order api Version:4.0.1 fix get_positions() https://github.com/Lu-Yi-Hsun/iqoptionapi/issues/132 add get_optioninfo_v2 Version:4.0.0 :exclamation::exclamation::exclamation: update websocket-client==0.56 :exclamation: please uninstall all websocket-client and update up websocket-client==0.56 sudo pip uninstall websocket-client sudo pip install websocket-client==0.56 :exclamation:","title":"Add option balance_mode on create IQ_Option objetct."},{"location":"pt/forex/","text":"How to trade with forex \u00b6","title":"Forex"},{"location":"pt/forex/#how-to-trade-with-forex","text":"","title":"How to trade with forex"}]}